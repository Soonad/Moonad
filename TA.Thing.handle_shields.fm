// Checks if there are shields to be used and update it if have
// handle_shields(hit_dmg: Number, self: Thing) : Thing 
//   case self |thing 
//   let init_val      = pair(__ hit_dmg, nil(_))
//   let res           = fold(__ init_val, use_shields, self.buf) 
//   let remaining_dmg = pair_fst(__ res) + self.dmg // Number actual damage taken
//   let remaining_buf = pair_snd(__ res) // List(Buff)
//   self <= thing(dmg = remaining_dmg, buf = remaining_buf)  

TA.Thing.handle_shields
  : (hit_dmg: F64)        ->
    (self: TA.Thing) ->
    TA.Thing
  (hit_dmg) (self)
  let self.buf = TA.Thing.get_buf(self)
  let self.dmg = TA.Thing.get_dmg(self)
  let init_val = 
    Pair.new<F64><List(TA.Game.Buff)>
    | hit_dmg;
    | List.nil<TA.Game.Buff>;
  let res = // fold(__ init_val, use_shields, self.buf) 
    List.fold<TA.Game.Buff><Pair(F64)(List(TA.Game.Buff))>
    | init_val;
    | TA.Game.use_shields;
    | self.buf;
  let res.fst = Pair.fst<F64><List(TA.Game.Buff)>(res)
  let res.snd = Pair.snd<F64><List(TA.Game.Buff)>(res)
  let remaining_dmg = F64.add(res.fst)(self.dmg) // Number actual damage taken
  let remaining_buf = res.snd // List(Buff)
  let self = TA.Thing.set_dmg(self)(remaining_dmg)
  let self = TA.Thing.set_buf(self)(remaining_buf)
  self
