T Parsec.State
| make(pos:Nat, str: String, errs: List(Parsec.Error));

T Parsec.Error
| new(pos: Nat, unx: Maybe(Parsec.Item), exp: List(Parsec.Item));

T Parsec.Item
| tokens(xs: String);
| label(xs: String);
| eof;

T Parsec.Reply<A: Type>
| value(state: Parsec.State, val: A);
| error(state: Parsec.State, err: Parsec.Error);

Parsec(A: Type): Type
  <B : Type> ->
  Parsec.State ->
  (Parsec.State -> A -> B) ->
  (Parsec.State -> Parsec.Error -> B) ->
  B

Parsec.Error.merge(x: Parsec.Error, y: Parsec.Error): Parsec.Error
  case x: | case y: |
  Nat.cmp(x.pos, y.pos)<_>(y)
  | def unx = x.unx<_>(y.unx,(x) Maybe.some<_>(x));
    Parsec.Error.new(x.pos, unx, List.concat<_>(x.exp,y.exp));
  | x;;;

Parsec.State.longest_match(x: Parsec.State, y: Parsec.State): Parsec.State
  case x: | case y: | Nat.cmp(x.pos,y.pos)<_>(y,x,x);;

Parsec.State.consumed(x: Parsec.State, y: Parsec.State): Bool
  case x: | case y: | Nat.gtn(y.pos,x.pos);;

Parsec.State.new(input: String) : Parsec.State
  Parsec.State.make(Nat.zero, input, List.nil<_>)

Parsec.run_state<A: Type>(p: Parsec(A), s: Parsec.State) : Parsec.Reply(A)
  p<_>(s)(Parsec.Reply.value<>)(Parsec.Reply.error<>)

Parsec.run<A: Type>(p: Parsec(A), s: String) : Parsec.Reply(A)
  p<_>(Parsec.State.new(s))(Parsec.Reply.value<>)(Parsec.Reply.error<>)

Parsec.token<A: Type>(f: Char -> Maybe(A), es: List(Parsec.Item)) : Parsec(A)
  <X> (s1) (val) (err)
  case s1: | case s1.str:
  | err(s1,Parsec.Error.new(s1.pos,Maybe.some<>(Parsec.Item.eof),es));
  | f(s1.str.head)<_>
    | def unx = Maybe.some<>(Parsec.Item.tokens(String.single(s1.str.head)))
      err(s1,Parsec.Error.new(s1.pos,unx,es));
    | (x) val(Parsec.State.make(Nat.succ(s1.pos), s1.str.tail, s1.errs), x);;;

Parsec.try<A: Type>(p: Parsec(A)) : Parsec(A)
  <X> (s1) (val) (err)
  p<X>(s1)
  | (s2) (x) val(s2,x);
  | (s2) (e) err(s1,e);

Parsec.take(n: Nat, lbl: String) : Parsec(String)
  <X> (s1) (val) (err)
  case s1: |
  let x = String.take_n(n,s1.str)
  case x:
  | def e = List.single<>(Parsec.Item.label(lbl))
    err(s1, Parsec.Error.new(s1.pos, Maybe.some<>(Parsec.Item.eof), e));
  | get took rest = x.value
    val(Parsec.State.make(Nat.add(s1.pos,n),rest,s1.errs), took);;

Parsec.take_while(f: Char -> Bool) : Parsec(String)
  <X> (s1) (val) (err)
  case s1: |
  get took rest = String.take_while(f,s1.str)
  val(Parsec.State.make(Nat.add(s1.pos,String.length(took)),rest,s1.errs),took);

//Parsec.testIO : IO(Unit)
//  def x = Parsec.test
//  IO.log<Unit>(x) | ()
//  IO.end<Unit>(Unit.new);
//
//Parsec.testIO2 : IO(Unit)
//  get x y = String.take_while((x) Bool.true,String.long)
//  IO.log<Unit>(x) | ()
//  IO.end<Unit>(Unit.new);
//
//Parsec.test : String
//  def p   = Parsec.take_while((x) Bool.true)
//  Parsec.run<String>(p, String.long)<() String>
//  | (s,x) x;
//  | (s,e) "Error";
//
//String.long : String
//  "aaa"
//// repeat as necessary
