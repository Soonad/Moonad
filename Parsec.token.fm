// parse a single character with a validator function 
// and a list of expected tokens

Parsec.token: <A: Type> -> (Char -> Maybe(A)) -> List(Parsec.Error.Item) -> Parsec(A)
  <A> (f) (es)
  <X> (s1) (empty_value) (empty_error) (eaten_value) (eaten_error)
  s1<() X> | (input) (index) (error)
  input<() X>
  | let unex = Maybe.some<Parsec.Error.Item>(Parsec.Error.Item.end_of_input)
    empty_error(s1)(Parsec.Error.make_trivial(Nat.zero)(unex)(es));
  | (c) (cs)
    f(c)<() X>
    | let item = Parsec.Error.Item.tokens(String.single(c))
      let unex = Maybe.some<Parsec.Error.Item>(item)
      empty_error(s1)(Parsec.Error.make_trivial(index)(unex)(es));
    | (x)
      let s2 = Parsec.State.make(cs)(Nat.succ(index))(error)
      eaten_value(s2)(x);;;

