// An unicode codepoint.
Char: Type
  U16

// Receives a hex char (0-9, a-f, A-F) and returns its value as a Nat.
Char.hex_value: Char -> Maybe(Nat)
  (chr)
  // if ('0' <= chr <= '9') return to_nat(chr - '0');
  case Bool.and(U16.gte(chr)('0'))(U16.lte(chr)('9')):
  | Maybe.some<Nat>(U16.to_nat(U16.sub(chr)('0')));
  // if ('a' <= chr < 'f') return to_nat(chr - 'a') + 10;
  | case Bool.and(U16.gte(chr)('a'))(U16.lte(chr)('f')):
    | Maybe.some<Nat>(Nat.add(U16.to_nat(U16.sub(chr)('a')))(Nat.10));
    // if ('A' <= chr < 'F') return to_nat(chr - 'a') + 10;
    // else return 0;
    | case Bool.and(U16.gte(chr)('A'))(U16.lte(chr)('F')):
      | Maybe.some<Nat>(Nat.add(U16.to_nat(U16.sub(chr)('A')))(Nat.10));
      | Maybe.none<Nat>;
    ;
  ;

// Creates a character from 16 bits.
Char.new
  : Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit ->
    Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit -> Bit ->
    Char
  (b0) (b1) (b2) (b3) (b4) (b5) (b6) (b7)
  (b8) (b9) (bA) (bB) (bC) (bD) (bE) (bF)
  let kF = b0<>(Word.0<>)(Word.1<>)
  let kE = b1<>(Word.0<>)(Word.1<>)
  let kD = b2<>(Word.0<>)(Word.1<>)
  let kC = b3<>(Word.0<>)(Word.1<>)
  let kB = b4<>(Word.0<>)(Word.1<>)
  let kA = b5<>(Word.0<>)(Word.1<>)
  let k9 = b6<>(Word.0<>)(Word.1<>)
  let k8 = b7<>(Word.0<>)(Word.1<>)
  let k7 = b8<>(Word.0<>)(Word.1<>)
  let k6 = b9<>(Word.0<>)(Word.1<>)
  let k5 = bA<>(Word.0<>)(Word.1<>)
  let k4 = bB<>(Word.0<>)(Word.1<>)
  let k3 = bC<>(Word.0<>)(Word.1<>)
  let k2 = bD<>(Word.0<>)(Word.1<>)
  let k1 = bE<>(Word.0<>)(Word.1<>)
  let k0 = bF<>(Word.0<>)(Word.1<>)
  let k_ = Word.nil
  U16.new(k0(k1(k2(k3(k4(k5(k6(k7(k8(k9(kA(kB(kC(kD(kE(kF(k_)))))))))))))))))

Char.newline: Char
  Char.new
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.1; | Bit.0; | Bit.1; | Bit.0;

// Parses a character. Example: `Char.parse("x")`
Char.parse : (str : String) -> Char.parse.type(str)
  (str)
  str<(str) Char.parse.type(str)>
  | Unit.new;
  | (str.head) (str.tail) str.head;

Char.parse.type : String -> Type
  (str)
  case str:
  | Unit;
  | (str.head) (str.tail) Char;

Char.quote : Char
  Char.new
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.0; | Bit.0; | Bit.1; | Bit.0;
  | Bit.0; | Bit.0; | Bit.1; | Bit.0;

Char.tab: Char
  Char.new
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.0; | Bit.0; | Bit.0; | Bit.0;
  | Bit.1; | Bit.0; | Bit.0; | Bit.1;

