// The polymorphic List type can hold a number of elements.
T List <A: Type>
| nil;
| cons(head: A, tail: List(A));

// Basic Functions
// ===============

// A proposition that a list is not the empty list
List.not_empty<A: Type>(xs: List(A)) : Type
  case xs:
  | Empty;
  | Unit;

// A theorem that List.cons isn't List.nil
List.cons_isnt_nil<A: Type>(x:A, xs: List(A))
  : Not(Equal(List(A),List.cons<A>(x,xs), List.nil<A>))
  def P = List.not_empty<A>
  (e) Equal.rewrite<List(A), List.cons<A>(x,xs), List.nil<A>,P>(e, Unit.new)

// A theorem that a list made with List.cons is not the empty list
List.cons_isnt_empty<A: Type>(
  x:A,
  xs: List(A)
): List.not_empty<A>(List.cons<A>(x,xs))
  def y = List.cons<A>(x,xs)
  case y:
  with e : Equal(List(A),y,y.self) = Equal.to<List(A),y>;
  | Empty.absurd(List.cons_isnt_nil<A>(x,xs,e),_);
  | Unit.new;

// Concatenates two lists.
List.concat<A: Type>(as: List(A), bs: List(A)): List(A)
  case as:
  | bs;
  | List.cons<>(as.head, List.concat<>(as.tail,bs));

// Get the head of a nonempty list
List.head<A: Type>(xs: List(A), not_empty: List.not_empty<A>(xs)) : A
  case xs:
  with ne : List.not_empty<A>(xs.self) = not_empty;
  | Empty.absurd(ne, A);
  | xs.head;

// Get the tail of a nonempty list
List.tail<A: Type>(xs: List(A), not_empty: List.not_empty<A>(xs)) : List(A)
  case xs:
  with ne : List.not_empty<A>(xs.self) = not_empty;
  | Empty.absurd(ne, List(A));
  | xs.tail;

// Get the all elements of a nonempty list except the last one
List.init<A: Type>(xs: List(A), not_empty: List.not_empty<A>(xs)) : List(A)
  case xs:
  with ne : List.not_empty<A>(xs.self) = not_empty;
  | Empty.absurd(ne, List(A));
  | case xs.tail:
    with e : Equal(_, xs.tail.self,xs.tail) = Equal.to<List(A),xs.tail>;
    | List.nil<>;
    | def cne = List.cons_isnt_empty<A>(xs.tail.head,xs.tail.tail)
      def xne = Equal.rewrite<_,_,_,(x) List.not_empty<A>(x)>(e,cne)
      List.cons<>(xs.head,List.init<>(xs.tail,xne));;

// Get the last element of a nonempty list
List.last<A: Type>(xs: List(A), not_empty: List.not_empty<A>(xs)) : A
  case xs:
  with ne : List.not_empty<A>(xs.self) = not_empty;
  | Empty.absurd(ne, A);
  | case xs.tail:
    with e : Equal(_, xs.tail.self,xs.tail) = Equal.to<List(A),xs.tail>;
    | xs.head;
    | def cne = List.cons_isnt_empty<A>(xs.tail.head,xs.tail.tail)
      def xne = Equal.rewrite<_,_,_,(x) List.not_empty<A>(x)>(e,cne)
      List.last<>(xs.tail,xne);;

List.null<A: Type>(xs: List(A)) : Bool
  case xs:
  | Bool.true;
  | Bool.false;

// Computes the length of the list.
List.length<A: Type>(xs: List(A)): Nat
  List.length.go<>(xs,Nat.zero)

List.length<A: Type>(xs: List(A), n: Nat): Nat
  case xs:
  | Nat.zero;
  | List.length<A>(xs.tail,Nat.succ(n));

// Appends element to the end of the list.
List.append<A: Type>(as: List(A), a: A): List(A)
  case as:
  | List.pure<>(a);
  | List.cons<>(as.head,List.append<>(as.tail, a));


// List transformations
// ====================

// Applies a function to all elements of the list.
List.map<A: Type, B: Type>(f: A -> B, as: List(A)): List(B)
  case as:
  | List.nil<>;
  | List.cons<>(f(as.head),List.map<,>(f,as.tail));

// Map over a list with the index
List.imap<A: Type,B: Type>(f: Nat -> A -> B, xs: List(A)): List(B)
  case xs:
  | List.nil<>;
  | List.cons<>(f(0,xs.head),List.imap<,>((n) f(Nat.succ(n)),xs.tail));

// Reverse the order of the elements of the list
List.reverse<A: Type>(xs: List(A)) : List(A)
  List.reverse.go<>(xs,List.nil<>)

List.reverse.go<A: Type>(xs: List(A), res: List(A)): List(A)
  case xs:
  | res;
  | List.reverse.go<>(xs.tail,List.cons<>(xs.head,res));

// insert separators between elements, i.e. `[A,B,C] ~> [A,sep,B,sep,C]`
List.intersperse<A: Type>(sep: A, xs: List(A)): List(A)
  case xs:
  | List.nil<>;
  | case xs.tail:
    | List.pure<>(xs.head);
    | List.cons<>(xs.head,List.cons<>(sep,List.intersperse<A>(sep,xs.tail)));;

// insert separators between elements, i.e. `[A,B,C] ~> [A,sep,B,sep,C]`
List.intercalate<A: Type>(sep: List(A), xs: List(List(A))): List(A)
  List.flatten<A>(List.intersperse<List(A)>(sep,xs))

// Reducing Lists
// ==============

// Folds over a list, right associative
List.foldr<A: Type,B: Type>(b: B, f: A -> B -> B, xs: List(A)): B
  List.foldr.go<,>(b,f,xs,(x) x)

List.foldr.go<A: Type,B: Type>(b: B, f: A -> B -> B, xs: List(A), g: B -> B): B
  case xs:
  | g(b);
  | List.foldr.go<,>(b,f,xs.tail,(x) f(xs.head,x));

// Folds over a list, left associative
List.foldl<A: Type,B: Type>(b: B, f: B -> A -> B, xs: List(A)): B
  case xs:
  | b;
  | List.foldl<,>(f(b,xs.head),f,xs.tail);

// Special folds
// =============

// Flattens a list of lists into a single list.
List.flatten<A: Type>(xs: List(List(A))): List(A)
  case xs:
  | List.nil<>;
  | List.concat<>(xs.head, List.flatten<>(xs.tail));

// Do all elements satisfy a condition?
List.all<A: Type>(cond: A -> Bool, list: List(A)): Bool
  case list:
  | Bool.true;
  | case cond(list.head):
    | List.all<>(cond)(list.tail);
    | Bool.false;;

// Are all elements true?
List.all_true(list: List(Bool)): Bool
  List.all<>((x) x)(list)

/// Do any element satisfy a condition?
List.any <A: Type>(cond: A -> Bool, list: List(A)): Bool
  case list:
  | Bool.false;
  | case cond(list.head):
    | Bool.true;
    | List.any<>(cond)(list.tail);;

// Is any element true?
List.any_true(list: List(Bool)): Bool
  List.any<>((x) x)(list)

// Print a list
List.show<A: Type>(f: A -> String, xs: List(A)): String
  List.show.go<>(f,xs,String.Builder.cons('[',String.Builder.new))

List.show.go<A: Type>(f: A -> String, xs: List(A), sb: String.Builder): String
  case xs:
  | sb(String.pure(']'));
  | List.show.go<>(f,xs.tail)
    | String.Builder.concat(String.to_builder(f(xs.head)))
      | String.Builder.cons(',',sb);;;

// Add the total of a list of natural numbers
List.sum(xs: List(Nat)) : Nat
  List.sum.go(xs, Nat.zero)

List.sum.go(xs: List(Nat), n: Nat) : Nat
  case xs:
  | Nat.zero;
  | List.sum.go(xs.tail,Nat.add(xs.head,n));


// List monad
// ==========

// A list with only one element.
List.pure<A : Type>(x : A) : List(A)
  List.cons<A>(x)(List.nil<A>)

// The bind function of the list Monad.
List.bind<A: Type,B: Type>(xs: List(A), f: A -> List(B)): List(B)
  List.flatten<>(List.map<,>(f)(xs))

// Sublists
// ========

// Removes the first elements of a list.
List.drop<A: Type>(n: Nat, xs: List(A)):  List(A)
  case n:
  | xs;
  | case xs:
    | List.nil<>;
    | List.drop<>(n.pred,xs.tail);;

// Remove elements while a condition is true
List.drop_while<A: Type>(f: A -> Bool, xs: List(A)): List(A)
  case xs:
  | List.nil<>;
  | case f(xs.head):
    | List.drop_while<>(f,xs.tail);
    | xs;;

List.drop_until<A: Type>(f: A -> Bool, xs: List(A)): List(A)
  List.drop_while<>((c) Bool.not(f(c)), xs)

// Removes all elements that do not satisfy a condition.
List.filter<A: Type>(f: A -> Bool, xs: List(A)): List(A)
  case xs:
  | List.nil<>;
  | case f(xs.head):
    | List.cons<>(xs.head,List.filter<>(f, xs.tail));
    | List.filter<>(f, xs.tail);;

// Returns the first elements of a list, discards the rest.
List.take<A: Type>(n: Nat, xs: List(A)): List(A)
  case xs:
  | List.nil<>;
  | case n:
    | List.nil<>;
    | List.cons<>(xs.head,List.take<>(n.pred, xs.tail));;

////String.take_n(n: Nat, str: String) : Maybe(Pair(String)(String))
////  def m = String.take_n.go(n)(String.nil)(str)
////  case m:
////  | Maybe.none<Pair(String)(String)>;
////  | get x y = m.value
////    Maybe.some<>(Pair.new<><>(String.reverse(x))(y));
////
////String.take_n.go(n: Nat, str: String, res: String) : Maybe(Pair(String,String))
////  case res:
////  | case n:
////    | Maybe.some<>(Pair.new<_,_>(str)(String.nil));
////    | Maybe.none<Pair(String)(String)>;;
////  | case n:
////    | Maybe.some<>(Pair.new<String><String>(str)(res));
////    | String.take_n.go(n.pred)(String.cons(res.head)(str))(res.tail);;
////
////
////String.take_while.go(f: Char -> Bool, str: String, res: String): Pair(String,String)
////  case res:
////  | Pair.new<><>(str)(String.nil);
////  | let x = f(res.head)
////    case x:
////    | String.take_while.go(f,String.cons(res.head)(str))(res.tail);
////    | Pair.new<><>(str,res);;
////
////String.take_while(f: Char -> Bool, str: String) : Pair(String)(String)
////  get x y = String.take_while.go(f,String.nil,str)
////  Pair.new<><>(String.reverse(x),y)

// List.Builder
// ============

// A lazy List constructor, useful for efficient concatenation
List.Builder(A: Type): Type
  List(A) -> List(A)

// construct a new builder (it's just the identity function)
List.Builder.new<A: Type> : List.Builder(A)
  (x) x

// turn a builder into a List
List.run_builder<A: Type>(lb: List.Builder(A)): List(A)
  lb(List.nil<>)

// concatenate two list builders
List.Builder.concat<A: Type>(a: List.Builder(A), b: List.Builder(A)): List.Builder(A)
   (x) a(b(x))

// prepend an element
List.Builder.cons<A: Type>(c: A, lb: List.Builder(A)) : List.Builder(A)
  (x) lb(List.cons<>(c,x))

// convert a list to a builder
List.to_builder<A: Type>(list: List(A)) : List.Builder(A)
  List.to_builder.go<>(list, List.Builder.new<>)

List.to_builder.go<A: Type>(list: List(A), lb: List.Builder(A)) : List.Builder(A)
  case list:
  | lb;
  | List.to_builder.go<>(list.tail)(List.Builder.cons<>(list.head, lb));

// Returns the element at given position.
List.at<A: Type>(list: List(A), index: Nat): Maybe(A)
  case list:
  | Maybe.none<>;
  | case index:
    | Maybe.some<>(list.head);
    | List.at<>(list.tail)(index.pred);;

List.chunk<A: Type>(n: Nat, xs: List(A)): Maybe(List(A))
  case n:
  | Maybe.some<>(List.nil<>);
  | case xs:
    | Maybe.none<>;
    | Maybe.bind<,>(List.chunk<>(n.pred,xs.tail))
      | (x) Maybe.some<>(List.cons<>(xs.head,x));;;

// Indexing Lists
// ==============

//Finds the first occurrence that satisfies a condition
List.find<A: Type>(cond: A -> Bool, xs: List(A)): Maybe(A)
  case xs:
  | Maybe.none<>;
  | case cond(xs.head):
    | Maybe.some<>(xs.head);
    | List.find<>(cond)(xs.tail);;

// Finds the last element that satisfies a condition and its index.
List.find_last<A: Type>(xs: List(A), f: A -> Nat -> Bool): Maybe(Pair(A)(Nat))
  List.find_last.go<A>(xs,f,Nat.zero,Maybe.none<>)

List.find_last.go<A: Type>(
  xs: List(A),
  f: A -> Nat -> Bool,
  n: Nat,
  res: Maybe(Pair(A,Nat))
): Maybe(Pair(A,Nat))
  case xs:
  | res;
  | let res = case f(xs.head,n):
      | Maybe.some<>(Pair.new<,>(xs.head,n));
      | res;
    List.find_last.go<>(xs.tail,f,Nat.succ(n),res);

// Finds the first element that satisfies a condition and its index.
List.ifind<A: Type>(xs: List(A), f: A -> Nat -> Bool): Maybe(Pair(A,Nat))
  List.ifind.go<A>(xs,f,Nat.zero)

List.ifind.go<A: Type>(xs: List(A), f: A -> Nat -> Bool, i: Nat): Maybe(Pair(A,Nat))
  case xs:
  | Maybe.none<>;
  | case f(xs.head,i):
    | Maybe.some<>(Pair.new<,>(xs.head)(i));
    | List.ifind.go<>(xs.tail,f,Nat.succ(i));;

// Zipping lists
// =============

// Given two lists `xs` and `ys`, applies `f(xs[i],ys[i])` for all `i`.
List.zip_with<A: Type, B: Type, C: Type>(f: A -> B -> C, as: List(A), bs: List(B))
  : List(C)
  case as:
  | List.nil<>;
  | case bs:
    | List.nil<>;
    | List.cons<>(f(as.head,bs.head),List.zip_with<,,>(f,as.tail,bs.tail));;
