// with dependent types, we can reason that a successful parser returns an A
// and an unsuccessful parser returns a lifted Parsec.Error(E) value
// (`The` lifts the Parsec.Error into a type so we can see it at compile time)

Parsec.parse: <A: Type> -> (p: Parsec(A)) -> (s: Parsec.State) -> Parsec.type(A)(Parsec.run<A>(p)(s))
  <A> (p) (s)
  Parsec.run<A>(p)(s)<(t) Parsec.type(A)(t)>
  | () (x) x;
  | () (e) e;
  | () (x) x;
  | () (e) e;


