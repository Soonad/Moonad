// This allows us to derive inductive datatypes types, constructors and generic
// functions (folds, stringification, etc.) from first-class descriptions. This
// is a WIP, right now it only supports simple types, no fields, and there are
// many things missing. But check the end of the file for a preview of how it
// will eventually work!
// From:
//   T Vector <A: Type>                       ~ (len: Nat)
//   | nil                                    ~ (Nat.zero);
//   | ext<len: Nat>(x: A, xs: Vector(A,len)) ~ (Nat.succ(len));
// To:
//   Vector (A: Type, len: Nat) : Type 
//     (A, len)
//     self(P: Nat -> Vector(A, len) -> Type) ->
//     (nil: P(Nat.zero)(Vector.nil<A>)) ->
//     (ext: <len: Nat> -> (x: A, xs: Vector<A>(len)) -> P(Nat.succ(len))(Vector.ext<A>(len)(x)(xs))) ->
//     P(len)(self)
// + constructors + generic functions

// Data: a type for inductive datatype descriptions
// ================================================

Data.Flds: Type
  self<P: Data.Flds -> Type> ->
  (nil:
    P(Data.Flds.nil)) ->
  (ext:
    (name: String) ->
    (type: Type) ->
    (flds: Data.Flds) ->
    P(Data.Flds.ext(name)(type)(flds))) ->
  P(self)

Data.Flds.nil: Data.Flds
  <P> (nil) (ext) nil

Data.Flds.ext: String -> Type -> Data.Flds -> Data.Flds
  (name) (type) (flds)
  <P> (nil) (ext) ext(name)(type)(flds)

Data.Ctrs: Type
  self<P: Data.Ctrs -> Type> ->
  (nil:
    P(Data.Ctrs.nil)) ->
  (ext:
    (name: String) ->
    (flds: Data.Flds) ->
    (ctrs: Data.Ctrs) ->
    P(Data.Ctrs.ext(name)(flds)(ctrs))) ->
  P(self)

Data.Ctrs.nil: Data.Ctrs
  <P> (nil) (ext) nil

Data.Ctrs.ext: String -> Data.Flds -> Data.Ctrs -> Data.Ctrs
  (name) (flds) (ctrs)
  <P> (nil) (ext) ext(name)(flds)(ctrs)

Data: Type
  self<P: Data -> Type> ->
  (new:
    (name: String) ->
    (ctrs: Data.Ctrs) ->
    P(Data.new(name)(ctrs))) ->
  P(self)

Data.new: String -> Data.Ctrs -> Data
  (name) (ctrs)
  <P> (new) new(name)(ctrs)

// Derivers for datatype types
// ===========================

Data.Flds.type: Type -> Data.Flds -> Type
  (P) (flds)
  flds<() Type>
  |#nil# P;
  |#ext# (flds.name) (flds.type) (flds.flds)
    (x: P) -> Data.Flds.type(P, flds.flds);
    
Data.Ctrs.type: Type -> Data.Ctrs -> Type
  (P) (ctr)
  ctr<() Type>
  |#nil# P;
  |#ext# (ctr.name) (ctr.flds) (ctr.ctrs)
    (ctr: Data.Flds.type(P, ctr.flds)) ->
    Data.Ctrs.type(P, ctr.ctrs);

Data.type: Data -> Type
  (data)
  data<() Type>
  | (data.name) (data.ctrs)
    self<P: Type> -> Data.Ctrs.type(P, data.ctrs);

// Derivers for constructors
// =========================

Data.Ctrs.ctr.header.type: (P: Type) -> Data.Ctrs -> List(P) -> Type
  (P) (ctrs) (vars)
  ctrs<() Type>
  |#nil# vars<() Type>(Unit, () () P);
  |#ext# (ctrs.name) (ctrs.flds) (ctrs.ctrs)
    (x: P) -> Data.Ctrs.ctr.header.type(P, ctrs.ctrs, List.cons<P>(x)(vars));

Data.Ctrs.ctr.header: (P: Type) -> (ctrs: Data.Ctrs) -> (vars: List(P)) -> Data.Ctrs.ctr.header.type(P, ctrs, vars)
  (P) (ctrs) (vars)
  ctrs<(ctrs) Data.Ctrs.ctr.header.type(P, ctrs, vars)>
  |#nil# vars<(vars) vars<() Type>(Unit, () () P)>(Unit.new, (h) (t) h); 
  |#ext# (ctrs.head) (ctrs.flds) (ctrs.ctrs) (x) Data.Ctrs.ctr.header(P, ctrs.ctrs, List.cons<P>(x)(vars));

Data.Ctrs.ctr.type: Data.Ctrs -> Data.Ctrs -> Nat -> Type
  (ctr) (ctr0) (nth)
  ctr<() Type>
  |#nil# Type;
  |#ext# (ctr.name) (ctr.flds) (ctr.ctrs)
    nth<() Type>
    |#zero# <P: Type> -> Data.Ctrs.ctr.header.type(P, ctr0, List.nil<P>);
    |#succ# (nth.pred) Data.Ctrs.ctr.type(ctr.ctrs, ctr0, nth.pred);;

Data.Ctrs.ctr: (ctrs: Data.Ctrs) -> (ctrs0: Data.Ctrs) -> (nth: Nat) -> Data.Ctrs.ctr.type(ctrs, ctrs0, nth)
  (ctrs) (ctrs0) (nth)
  ctrs<(ctrs) Data.Ctrs.ctr.type(ctrs, ctrs0, nth)>
  |#nil# Type;
  |#ext# (ctrs.name) (ctrs.flds) (ctrs.ctrs)
    def ctrs = Data.Ctrs.ext(ctrs.name)(ctrs.flds)(ctrs.ctrs)
    nth<(nth) Data.Ctrs.ctr.type(ctrs, ctrs0, nth)>
    |#zero# <P> Data.Ctrs.ctr.header(P, ctrs0, List.nil<P>);
    |#succ# (nth.pred) Data.Ctrs.ctr(ctrs.ctrs, ctrs0, nth.pred); ;

Data.ctr: (data: Data) -> (nth: Nat) -> Data.ctr.type(data, nth)
  (data, nth)
  data<(data) Data.ctr.type(data, nth)>
  |#new# (data.name) (data.ctrs)
    def data = Data.new(data.name)(data.ctrs)
    Data.Ctrs.ctr(data.ctrs, data.ctrs, nth) ;

Data.ctr.type: Data -> Nat -> Type
  (data) (nth)
  data<() Type>
  | (data.name) (data.ctrs) Data.Ctrs.ctr.type(data.ctrs, data.ctrs, nth);


// Examples
// ========

// Describes the "Bit" datatype
//   T Bit
//   | b0
//   | b1
Bit.Data: Data
  Data.new("Bit")
  | Data.Ctrs.ext("b0", Data.Flds.nil,
    Data.Ctrs.ext("b1", Data.Flds.nil,
    Data.Ctrs.nil));

// Derives the type of "Bit"
//   Bit.Type: Type
//     <P: Type> -> (b0: P) -> (b1: P) -> P
Bit.Type: Type
  Data.type(Bit.Data)
  
// Derives the first constructor of "Bit"
//   Bit.Ctr.0: <P: Type> -> (b0: P) -> (b1: P) -> P
//     <P> (b0) (b1) b0
Bit.Ctr.0: Data.ctr.type(Bit.Data)(Nat.0)
  Data.ctr(Bit.Data)(Nat.0)


// Describes the "Nat" datatype
//   T Nat
//   | z
//   | s(pred: Nat)
Nat.Data: Data
  Data.new("Nat")
  | Data.Ctrs.ext("z", Data.Flds.nil,
    Data.Ctrs.ext("s",
      Data.Flds.ext("pred", Data.type(Nat.Data),
      Data.Flds.nil),
    Data.Ctrs.nil));

// Derives the type of "Bit"
//   Bit.Type: Type
//     <P: Type> -> (b0: P) -> (b1: P) -> P
Nat.Type: Type
  Data.type(Nat.Data)
  
// Derives the first constructor of "Bit"
//   Bit.Ctr.0: <P: Type> -> (b0: P) -> (b1: P) -> P
//     <P> (b0) (b1) b0
//Bit.Ctr.0: Data.ctr.type(Bit.Data)(Nat.0)
  //Data.ctr(Bit.Data)(Nat.0)

