// This allows us to derive inductive datatypes types, constructors and generic
// functions (folds, stringification, etc.) from first-class descriptions. This
// is a WIP, right now it only supports simple types, no fields, and there are
// many things missing. But check the end of the file for a preview of how it
// will eventually work!

// From:
//
// T Vector <A: Type> (len: Nat)
// | nil                                   : Vector<A>(Nat.zero);
// | ext(n: Nat, x: A, xs: Vector<A>(len)) : Vector<A>(Nat.succ(len));
//
// To:
//
// Vector <A: Type> (len: Nat) : Type 
//   vector(P: Vector<A>(len) -> Type) ->
//   (nil: P(Nat.zero)) ->
//   (ext: (n: Nat, x: A, xs: Vector<A>(len)) -> P(Nat.succ(len))(Vector.ext<A>(n)(x)(xs))) ->
//   P(len)(vector)
//
// + constructors + generic functions

// Data: a type for inductive datatype descriptions
// ================================================

Data.Flds: Type
  self<P: Data.Flds -> Type> ->
  (nil:
    P(Data.Flds.nil)) ->
  (ext:
    (name: String) ->
    (type: Data) ->
    (flds: Data.Flds) ->
    P(Data.Flds.ext(name)(type)(flds))) ->
  P(self)

Data.Flds.nil: Data.Flds
  <P> (nil) (ext) nil

Data.Flds.ext: String -> Data -> Data.Flds -> Data.Flds
  (name) (type) (flds)
  <P> (nil) (ext) ext(name)(type)(flds)

Data.Ctrs: Type
  self<P: Data.Ctrs -> Type> ->
  (nil:
    P(Data.Ctrs.nil)) ->
  (ext:
    (name: String) ->
    (flds: Data.Flds) ->
    (ctrs: Data.Ctrs) ->
    P(Data.Ctrs.ext(name)(flds)(ctrs))) ->
  P(self)

Data.Ctrs.nil: Data.Ctrs
  <P> (nil) (ext) nil

Data.Ctrs.ext: String -> Data.Flds -> Data.Ctrs -> Data.Ctrs
  (name) (flds) (ctrs)
  <P> (nil) (ext) ext(name)(flds)(ctrs)

Data: Type
  self<P: Data -> Type> ->
  (new:
    (name: String) ->
    (ctrs: Data.Ctrs) ->
    P(Data.new(name)(ctrs))) ->
  P(self)

Data.new: String -> Data.Ctrs -> Data
  (name) (ctrs)
  <P> (new) new(name)(ctrs)

// Derivers for datatype types
// ===========================

Data.Flds.type: Type -> Data.Flds -> Type
  (P) (flds)
  flds<() Type>
  |#nil# P;
  |#ext# (flds.name) (flds.type) (flds.flds)
    (x: P) -> Data.Flds.type(P, flds.flds);
    
Data.Ctrs.type: Type -> Data.Ctrs -> Type
  (P) (ctr)
  ctr<() Type>
  |#nil# P;
  |#ext# (ctr.name) (ctr.flds) (ctr.ctrs)
    (ctr: Data.Flds.type(P, ctr.flds)) ->
    Data.Ctrs.type(P, ctr.ctrs);

Data.type: Data -> Type
  (data)
  data<() Type>
  | (data.name) (data.ctrs)
    self<P: Type> -> Data.Ctrs.type(P, data.ctrs);

// Derivers for constructor types
// ==============================

//Data.Flds.ctr_type: (P: Type) -> Data.Flds -> List(P) -> Type
  //(P) (flds) (vars)
  //flds<() Type>
  //|#nil# vars<() Type>(Unit, () () P);
  //|#ext# (flds.name) (flds.type) (flds.flds)
    //(x: P) -> Data.Flds.ctr_type(P, flds.flds, List.cons<P>(x)(vars));

Data.Ctrs.ctr_type.header: (P: Type) -> Data.Ctrs -> List(P) -> Type
  (P) (ctrs) (vars)
  ctrs<() Type>
  |#nil# vars<() Type>(Unit, () () P);
  |#ext# (ctrs.name) (ctrs.flds) (ctrs.ctrs)
    (x: P) -> Data.Ctrs.ctr_type.header(P, ctrs.ctrs, List.cons<P>(x)(vars));

Data.Ctrs.ctr_type: Data.Ctrs -> Data.Ctrs -> Nat -> Type
  (ctr) (ctr0) (nth)
  ctr<() Type>
  |#nil# Type;
  |#ext# (ctr.name) (ctr.flds) (ctr.ctrs)
    nth<() Type>
    |#zero# <P: Type> -> Data.Ctrs.ctr_type.header(P, ctr0, List.nil<P>);
    |#succ# (nth.pred) Data.Ctrs.ctr_type(ctr.ctrs, ctr0, nth.pred);;

Data.ctr_type: Data -> Nat -> Type
  (data) (nth)
  data<() Type>
  | (data.name) (data.ctrs) Data.Ctrs.ctr_type(data.ctrs, data.ctrs, nth);

// Derivers for constructors
// =========================

//Found type... Data.Ctrs.ctr_type(Data.type(data))(data.ctrs)(nth)
//Instead of... Data.ctr_type(data)(nth)

Data.Ctrs.ctr.header: (P: Type) -> (ctrs: Data.Ctrs) -> (vars: List(P)) -> Data.Ctrs.ctr_type.header(P, ctrs, vars)
  (P) (ctrs) (vars)
  ctrs<(ctrs) Data.Ctrs.ctr_type.header(P, ctrs, vars)>
  |#nil# vars<(vars) vars<() Type>(Unit, () () P)>(Unit.new, (h) (t) h); 
  |#ext# (ctrs.head) (ctrs.flds) (ctrs.ctrs) (x) Data.Ctrs.ctr.header(P, ctrs.ctrs, List.cons<P>(x)(vars));

Data.Ctrs.ctr: (ctrs: Data.Ctrs) -> (ctrs0: Data.Ctrs) -> (nth: Nat) -> Data.Ctrs.ctr_type(ctrs, ctrs0, nth)
  (ctrs) (ctrs0) (nth)
  ctrs<(ctrs) Data.Ctrs.ctr_type(ctrs, ctrs0, nth)>
  |#nil# Type;
  |#ext# (ctrs.name) (ctrs.flds) (ctrs.ctrs)
    def ctrs = Data.Ctrs.ext(ctrs.name)(ctrs.flds)(ctrs.ctrs)
    nth<(nth) Data.Ctrs.ctr_type(ctrs, ctrs0, nth)>
    |#zero# <P> Data.Ctrs.ctr.header(P, ctrs0, List.nil<P>);
    |#succ# (nth.pred) Data.Ctrs.ctr(ctrs.ctrs, ctrs0, nth.pred); ;

Data.ctr: (data: Data) -> (nth: Nat) -> Data.ctr_type(data, nth)
  (data, nth)
  data<(data) Data.ctr_type(data, nth)>
  |#new# (data.name) (data.ctrs)
    def data = Data.new(data.name)(data.ctrs)
    Data.Ctrs.ctr(data.ctrs, data.ctrs, nth) ;

// Examples
// ========

// Describes the "Bit" datatype
//   T Bit
//   | b0
//   | b1
Bit.Data: Data
  Data.new("Bit")
  | Data.Ctrs.ext("b0", Data.Flds.nil,
    Data.Ctrs.ext("b1", Data.Flds.nil,
    Data.Ctrs.nil));

// Derives the type of "Bit"
//   Bit.Type: Type
//     <P: Type> -> (b0: P) -> (b1: P) -> P
Bit.Type: Type
  Data.type(Bit.Data)
  
// Derives the first constructor of "Bit"
//   Bit.Ctr.0: <P: Type> -> (b0: P) -> (b1: P) -> P
//     <P> (b0) (b1) b0
Bit.Ctr.0: Data.ctr_type(Bit.Data)(Nat.0)
  Data.ctr(Bit.Data)(Nat.0)
