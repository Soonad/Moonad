Parser.Error: Type
  Parsec.Error(Unit)

Parser.Error.show: Parser.Error -> String
  (e)
  e<() String>
  | (position) (unexpect) (expected) 
    String.concat("Error at ")        |
    String.concat(Nat.show(position)) |
    String.concat(":")                |
    String.concat
    | unexpect<() String>("")
      | (v) String.concat(" unexpected ") |
            String.concat(Parsec.Error.Item.show(v))(",");;; 
                                      |
    String.concat(" expected ")
    | List.show<Parsec.Error.Item>(Parsec.Error.Item.show)(expected);;;;;;
  | (position) (messages) "fancy";

Parser.Reply: Type -> Type
  (A) Parsec.Reply(Unit)(Unit)(A)

Parser.State.default: String -> Parser.State
  (input) Parsec.State.default<Unit><Unit>(input)(Unit.new)

Parser.State : Type
  Parsec.State(Unit)(Unit)

Parser.any_char : Parser(Char)
  Parsec.any_char<Unit><Unit>

Parser.ap: <A: Type> -> <B: Type> -> Parser(A -> B) -> Parser(A) -> Parser(B)
  <A> <B> (pf) (pa)
  Parsec.ap<Unit><Unit><A><B>(pf)(pa)

Parser.bind: <A: Type> -> <B: Type> -> Parser(A) -> (A -> Parser(B)) -> Parser(B)
  <A> <B> (pa) (pf) Parsec.bind<Unit><Unit><A><B>(pa)(pf)


Parser.char : Char -> Parser(Char)
  (c) Parsec.char<Unit><Unit>(c)

Parser.choice: <A: Type> -> List(Parser(A)) -> Parser(A)
  <A> (ps) Parsec.choice<Unit><Unit><A>(ps)

Parser.eof : Parser(Unit)
  Parsec.eof<Unit><Unit>

Parser.fail: <A: Type> -> String -> Parser(A)
  <A> (msg) Parsec.fail<Unit><Unit><A>(msg)

Parser : Type -> Type
  (A) Parsec(Unit)(Unit)(A)

Parser.label : <A: Type> -> String -> Parser(A) -> Parser(A)
  <A> (label) (p)
  Parsec.label<Unit><Unit><A>(label)(p)

Parser.many: <A: Type> -> Parser(A) -> Parser(List(A))
  <A> (p) Parsec.many<Unit><Unit><A>(p)

Parser.many_till: <A: Type> -> <B: Type> -> Parser(A) -> Parser(B) -> Parser(List(A))
  <A> <B> (p) (q)
  Parser.plus<List(A)>
  | Parser.then<B><List(A)>(q)(Parser.pure<List(A)>(List.nil<A>));
  | Parser.bind<A><List(A)>(p) | (x)
    Parser.bind<List(A)><List(A)>(Parser.many_till<A><B>(p)(q)) | (xs)
    Parser.pure<List(A)>(List.cons<A>(x)(xs));;;


Parser.observing: <A: Type> -> Parser(A) -> Parser(Either(Parser.Error)(A))
  <A> (p)
  Parsec.observing<Unit><Unit><A>(p)


Parser.optional: <A: Type> -> Parser(A) -> Parser(Maybe(A))
  <A> (p) Parsec.optional<Unit><Unit><A>(p)

Parser.parse:
  <A: Type> ->
  (p: Parser(A)) ->
  (s: String) ->
  Parser.type(A)(Parser.run<A>(p)(Parser.State.default(s)))

  <A> (p) (s)
  Parsec.parse<Unit><Unit><A>(p)(Parser.State.default(s))



Parser.plus: <A: Type> -> Parser(A) -> Parser(A) -> Parser(A)
  <A> (p) (q)
  Parsec.plus<Unit><Unit><A>(p)(q)


Parser.pure: <A: Type> -> (a: A) -> Parser(A)
  <A> (a)
  <X> (s) (empty_value) () () () empty_value(s)(a)

Parser.run: <A: Type> -> Parser(A) -> Parser.State -> Parser.Reply(A)
  <A> (p) (s)
  Parsec.run<Unit><Unit><A>(p)(s)

Parser.run_default: <A: Type> -> Parser(A) -> String -> Parser.Reply(A)
  <A> (p) (s)
  Parsec.run<Unit><Unit><A>(p)(Parser.State.default(s))

Parser.run_either: <A: Type> -> Parser(A) -> String -> Either(Parser.Error)(A)
  <A> (p) (s)
  let reply = Parsec.run<Unit><Unit><A>(p)(Parser.State.default(s))
  reply<() Either(Parser.Error)(A)>
  | () (x) Either.right<Parser.Error><A>(x);
  | () (e) Either.left<Parser.Error><A>(e);
  | () (x) Either.right<Parser.Error><A>(x);
  | () (e) Either.left<Parser.Error><A>(e);

Parser.skip_many: <A: Type> -> Parser(A) -> Parser(Unit)
  <A> (p)
  Parsec.skip_many<Unit><Unit><A>(p)


Parser.take: <A: Type> -> String -> Nat -> Parser(String)
  <A> (err) (n)
  Parsec.take<Unit><Unit><A>(err)(n)

Parser.take_while: (Char -> Bool) -> Parser(String)
  (f) Parsec.take_while<Unit><Unit>(f)

Parser.take_while1: String -> (Char -> Bool) -> Parser(String)
  (err) (f) Parsec.take_while1<Unit><Unit>(err)(f)

//Parser.test : String
//  Parser.parse<String>
//  | Parser.tokens("a");
//  | "a";




Parser.then: <A: Type> -> <B: Type> -> Parser(A) -> Parser(B) -> Parser(B)
  <A> <B> (pa) (pb)
  Parsec.then<Unit><Unit><A><B>(pa)(pb)

// parse a single character with a validator function 
// and a list of expected tokens

Parser.token:
  <A: Type> ->
  (Char -> Maybe(A)) ->
  List(Parsec.Error.Item) ->
  Parser(A)

  <A> (f) (es)
  Parsec.token<Unit><Unit><A>(f)(es)


Parser.tokens: String -> Parser(String)
  (str) Parsec.tokens<Unit><Unit>(str)


Parser.try : <A: Type> -> Parser(A) -> Parser(A)
  <A> (p) Parsec.try<Unit><Unit><A>(p)

Parser.type: (A: Type) -> Parser.Reply(A) -> Type
  (A) (reply) Parsec.type(Unit)(Unit)(A)(reply)


Parser.zero: <A: Type> -> Parser(A)
  <A> Parsec.zero<Unit><Unit><A>


