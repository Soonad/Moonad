Jacobian.wNAF.tco: List(Jacobian) -> Jacobian -> Jacobian -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Nat -> Pair(Jacobian)(Jacobian)
  (precomputes) (p) (f) (n) (W) (window) (windows) (windowSize) (mask) (maxNumber) Bool.if<Unit -> Pair(Jacobian)(Jacobian)>(Nat.ltn(window)(windows))(() let offset = Nat.mul(window)(windowSize); let wbits = Nat.bitwise_and(n)(mask); let n = Nat.div(n)(maxNumber); Bool.if<Pair(Nat)(Nat)>(Nat.gtn(wbits)(windowSize))(Pair.new<Nat><Nat>(Nat.succ(n))(Nat.sub(wbits)(maxNumber)))(Pair.new<Nat><Nat>(n)(wbits))<(x) Pair(Jacobian)(Jacobian)>((n) (wbits) Bool.if<Pair(Jacobian)(Jacobian)>(Nat.eql(wbits)(0))(let q = Maybe.extract<Jacobian>(List.at<Jacobian>(precomputes)(offset))(Jacobian.0); let f = Jacobian.add(f)(Bool.if<Jacobian>(Nat.odd(window))(Jacobian.negate(q))(q)); let window = Nat.succ(window); Jacobian.wNAF.tco(precomputes)(p)(f)(n)(W)(window)(windows)(windowSize)(mask)(maxNumber))(let cached = Maybe.extract<Jacobian>(List.at<Jacobian>(precomputes)(Nat.pred(Nat.add(offset)(wbits))))(Jacobian.0); let p = Jacobian.add(p)(cached); let window = Nat.succ(window); Jacobian.wNAF.tco(precomputes)(p)(f)(n)(W)(window)(windows)(windowSize)(mask)(maxNumber))))(() Pair.new<Jacobian><Jacobian>(p)(f))(Unit.new)

