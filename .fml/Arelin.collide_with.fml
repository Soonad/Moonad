Arelin.collide_with: (a_pos: F64.V3) -> (a_dir: F64.V3) -> (a_box: Arelin.Game.Hitbox) -> (b_pos: F64.V3) -> (b_dir: F64.V3) -> (b_box: Arelin.Game.Hitbox) -> Maybe(F64.V3)
  (a_pos) (a_dir) (a_box) (b_pos) (b_dir) (b_box) a_box<(self) Maybe(F64.V3)>(Maybe.none<F64.V3>)((a_box.rad) b_box<(self) Maybe(F64.V3)>(Maybe.none<F64.V3>)((b_box.rad) let dst = F64.V3.dist(a_pos)(b_pos); let rad = F64.add(a_box.rad)(b_box.rad); Bool.and(F64.gtn(dst)(F64.0))(F64.ltn(dst)(rad))<(self) Maybe(F64.V3)>(let out_dir = F64.V3.norm(F64.V3.sub(a_pos)(b_pos)); let out_vec = F64.V3.scale(F64.sub(rad)(dst))(out_dir); Maybe.some<F64.V3>(out_vec))(Maybe.none<F64.V3>))((b_box.pts) let nil = Maybe.none<F64.V3>; let cons = ((segment) (result) result<(self) Maybe(F64.V3)>(segment<(x11) Maybe(F64.V3)>((segment.a) (segment.b) let dst = F64.V3.point_segment_dist(a_pos)(segment); let rad = a_box.rad; F64.ltn(dst)(rad)<(self) Maybe(F64.V3)>(let out_dir = F64.V3.rot_90(F64.V3.norm(F64.V3.sub(segment.a)(segment.b))); let out_vec = F64.V3.scale(F64.sub(rad)(dst))(out_dir); Maybe.some<F64.V3>(out_vec))(Maybe.none<F64.V3>)))((value) Maybe.some<F64.V3>(value))) :: F64.Segment -> Maybe(F64.V3) -> Maybe(F64.V3); let segs = F64.V3.polygon_to_segments(b_pos)(b_dir)(b_box.pts); List.fold<F64.Segment><Maybe(F64.V3)>(nil)(cons)(segs)))((a_box.pts) Maybe.none<F64.V3>)

