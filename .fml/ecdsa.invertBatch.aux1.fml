ecdsa.invertBatch.aux1: (nums: List(Nat)) -> (modulo: Nat) -> (acc: Nat) -> (scratch: List(Nat)) -> (rest: List(Nat)) -> Pair(Nat)(Pair(List(Nat))(List(Nat)))
  (nums) (modulo) (acc) (scratch) (rest) nums<(nums.self) Pair(Nat)(Pair(List(Nat))(List(Nat)))>(Pair.new<Nat><Pair(List(Nat))(List(Nat))>(acc)(Pair.new<List(Nat)><List(Nat)>(scratch)(rest)))((nums.head) (nums.tail) Nat.eql(nums.head)(0)<(self.self) Pair(Nat)(Pair(List(Nat))(List(Nat)))>(let scratch = List.cons<Nat>(0)(scratch); let rest = List.cons<Nat>(nums.head)(rest); ecdsa.invertBatch.aux1(nums.tail)(modulo)(acc)(scratch)(rest))(let scratch = List.cons<Nat>(acc)(scratch); let acc = Nat.mod(Nat.mul(acc)(nums.head))(modulo); let rest = List.cons<Nat>(nums.head)(rest); ecdsa.invertBatch.aux1(nums.tail)(modulo)(acc)(scratch)(rest)))

