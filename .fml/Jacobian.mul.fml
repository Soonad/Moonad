Jacobian.mul: (scalar: Nat) -> (w: Nat) -> (precomputes: List(Jacobian)) -> Jacobian
  (scalar) (w) (precomputes) let n = Nat.mod(scalar)(CURVE.n); ecdsa.split_scalar(n)<(x) Jacobian>((k1) (k2) Int.toNat(k1)<(x) Jacobian>((k1neg) (k1) Int.toNat(k2)<(x) Jacobian>((k2neg) (k2) Jacobian.wNAF(w)(precomputes)(k1)<(x) Jacobian>((k1p) (f1p) Jacobian.wNAF(w)(precomputes)(k2)<(x) Jacobian>((k2p) (f2p) let k1p = Bool.if<Jacobian>(k1neg)(Jacobian.negate(k1p))(k1p); let k2p = Bool.if<Jacobian>(k2neg)(Jacobian.negate(k2p))(k2p); let k2p = k2p<(self) Jacobian>((k2p.x) (k2p.y) (k2p.z) Jacobian.new(ecdsa.mod(Nat.mul(k2p.x)(CURVE.beta)))(k2p.y)(k2p.z)); let point = Jacobian.add(k1p)(k2p); let fake = Jacobian.add(f1p)(f2p); fake<(self) Jacobian>((_) (_) (_) Jacobian.normalizeZ(point)))))))

