// A Map from bitstrings to values.
T Map (A: Type)
| new;
| tie(val: Maybe(A), lft: Map(A), rgt: Map(A));

// Returns the element stored at a given key, if any.
// Example: Map.get<Nat>(my_key, my_map)
Map.get<A: Type>(bits: Bits, map: Map(A)): Maybe(A)
  case bits:
  | case map:
    | Maybe.none<>;
    | map.val;;
  | case map:
    | Maybe.none<>;
    | Map.get<>(bits.pred, map.lft);;
  | case map:
    | Maybe.none<>;
    | Map.get<>(bits.pred, map.rgt);;

// Returns the element stored at a given key and a copy of the map.
Map.lookup<A: Type>(bits: Bits, val: A, map: Map(A)): Pair(A, Map(A))
  case bits:
  | case map:
    | let map = Map.tie<>(Maybe.some<>(val), Map.new<>, Map.new<>)
      Pair.new<><>(val, map);
    | let value = Maybe.extract<>(map.val, val)
      let map = Map.tie<>(Maybe.some<>(value), map.lft, map.rgt)
      Pair.new<><>(value, map);;
  | case map:
    | get p.fst p.snd = Map.lookup<>(bits.pred, val, Map.new<>)
      Pair.new<><>(p.fst, Map.tie<>(Maybe.none<>, p.snd, Map.new<>));
    | get p.fst p.snd = Map.lookup<>(bits.pred, val, map.lft)
      Pair.new<><>(p.fst, Map.tie<>(map.val, p.snd, map.rgt));;
  | case map:
    | get p.fst p.snd = Map.lookup<>(bits.pred, val, Map.new<>)
      Pair.new<><>(p.fst, Map.tie<>(Maybe.none<>, Map.new<>, p.snd));
    | get p.fst p.snd = Map.lookup<>(bits.pred, val, map.rgt)
      Pair.new<><>(p.fst, Map.tie<>(map.val, map.lft, p.snd));;

// Inserts a (key,val) pair in a map.
// Example: Map.get<Nat>(my_key, my_val, my_map)
Map.set<A: Type>(bits: Bits, val: A, map: Map(A)): Map(A)
  case bits:
  | case map:
    | Map.tie<>(Maybe.some<>(val), Map.new<>, Map.new<>);
    | Map.tie<>(Maybe.some<>(val), map.lft, map.rgt);;
  | case map:
    | Map.tie<>(Maybe.none<>, Map.set<>(bits.pred, val, Map.new<>), Map.new<>);
    | Map.tie<>(map.val, Map.set<>(bits.pred, val, map.lft), map.rgt);;
  | case map:
    | Map.tie<>(Maybe.none<>, Map.new<>, Map.set<>(bits.pred, val, Map.new<>));
    | Map.tie<>(map.val, map.lft, Map.set<>(bits.pred, val, map.rgt));;

// Modifies the element at a given key, returns it and a copy of the map.
// This used to be important on linear back-ends, but it isn't linear anymore.
// TODO: use `with` to make this function linear again.
query<A: Type>(cpy: A -> Pair(A, A), bits: Bits, map: Map(A)): Pair(Map(A), Maybe(A))
  case bits:
  | case map:
    | let map = Map.new<>
      let val = Maybe.none<>
      Pair.new<><>(map, val);
    | case map.val:
      | let map = Map.tie<>(Maybe.none<>, map.lft, map.rgt)
        let val = Maybe.none<>
        Pair.new<><>(map, val);
      | get p.fst p.snd = cpy(map.val.value)
        let map = Map.tie<>(Maybe.some<>(p.fst), map.lft, map.rgt)
        let val = Maybe.some<>(p.snd)
        Pair.new<><>(map, val);;;
  | case map:
    | let map = Map.new<>
      let val = Maybe.none<>
      Pair.new<><>(map, val);
    | get p.fst p.snd = query<>(cpy, bits.pred, map.lft)
      let map = Map.tie<>(map.val, p.fst, map.rgt)
      let val = p.snd
      Pair.new<><>(map, val);;
  | case map:
    | let map = Map.new<>
      let val = Maybe.none<>
      Pair.new<><>(map, val);
    | get p.fst p.snd = query<>(cpy, bits.pred, map.rgt)
      let map = Map.tie<>(map.val, map.lft, p.fst)
      let val = p.snd
      Pair.new<><>(map, val);;
