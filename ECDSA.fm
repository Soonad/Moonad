// Params: a, b
CURVE.a: Nat
  Nat.0

CURVE.b: Nat
  Nat.7

// Field over which we'll do calculations
CURVE.P: Nat
  Nat.parse_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")

// Subgroup order aka prime_order
CURVE.n: Nat
  Nat.parse_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")

// Cofactor
CURVE.h: Nat
  Nat.parse_hex("1")

// Base point (x, y) aka generator point
CURVE.Gx: Nat
  Nat.parse_hex("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798")

CURVE.Gy: Nat
  Nat.parse_hex("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8")

// For endomorphism, see below.
CURVE.beta: Nat
  Nat.parse_hex("7AE96A2B657C07106E64479EAC3434E99CF0497512F58995C1396C28719501EE")

ecdsa.mod: Nat -> Nat
  (a) Nat.mod(a)(CURVE.P)

ecdsa.negate: Nat -> Nat
  (a)
  Nat.eql(a)(Nat.0)<() Nat>
  | Nat.0;
  | Nat.sub(CURVE.P)(ecdsa.mod(a));

ecdsa.sub: Nat -> Nat -> Nat
  (a) (b) ecdsa.mod(Nat.add(a)(ecdsa.negate(b)))

ecdsa.P_DIV4_1: Nat
  Nat.div(Nat.add(CURVE.P)(Nat.1))(Nat.4)

// RHS of elliptic curve equation
ecdsa.weistrass: Nat -> Nat
  (x)
  ecdsa.mod(Nat.add(Nat.add(Nat.mulVar(Nat.3)(x)(x)(x))(Nat.mul(CURVE.a)(x)))(CURVE.b))

ecdsa.PRIME_SIZE: Nat
  Nat.parse_decimal("256")

ecdsa.USE_ENDOMORPHISM: Bool
  Nat.eql(CURVE.a)(Nat.0)

Point: Type
  Pair(Nat)(Nat)

Point.new: Nat -> Nat -> Point
  (x) (y) Pair.new<Nat><Nat>(x)(y)

// Jacobian point works in jacobi coordinates: (x, y, z) ~ (x/z^2, y/z^3)
Jacobian: Type
  jacobian<P: Jacobian -> Type> ->
  (new: (x: Nat) -> (y: Nat) -> (z: Nat)-> P(Jacobian.new(x)(y)(z))) ->
  P(jacobian)

Jacobian.new: Nat -> Nat -> Nat -> Jacobian
  (x) (y) (z)
  <P> (point) point(x)(y)(z)

Jacobian.0: Jacobian
  Jacobian.new(Nat.0)(Nat.0)(Nat.1)

Jacobian.equal: Jacobian -> Jacobian -> Bool
  (a) (b)
  a<() Bool>
  | (a.x) (a.y) (a.z)
    b<() Bool>
    | (b.x) (b.y) (b.z)
      let a.z2 = ecdsa.mod(Nat.mul(a.z)(a.z))
      let a.z3 = ecdsa.mod(Nat.mul(a.z)(a.z2))
      let b.z2 = ecdsa.mod(Nat.mul(b.z)(b.z))
      let b.z3 = ecdsa.mod(Nat.mul(b.z)(b.z2))
      let eq1 = Nat.eql(ecdsa.mod(Nat.mul(a.x)(b.z2)))(ecdsa.mod(Nat.mul(b.x)(a.z2)))
      let eq2 = Nat.eql(ecdsa.mod(Nat.mul(a.y)(b.z3)))(ecdsa.mod(Nat.mul(b.y)(a.z3)))
      Bool.and(eq1)(eq2);;

Jacobian.fromPoint: Point -> Jacobian
  (p)
  p<() Jacobian>
  | (p.x) (p.y) Jacobian.new(p.x)(p.y)(Nat.1);

Jacobian.negate: Jacobian -> Jacobian
  (p)
  p<() Jacobian>
  | (p.x) (p.y) (p.z) Jacobian.new(p.x)(ecdsa.negate(p.y))(p.z);

Jacobian.double: Jacobian -> Jacobian
  (p)
  p<() Jacobian>
  | (p.x) (p.y) (p.z)
    let A = Nat.square(p.x)
    let B = Nat.square(p.y)
    let C = Nat.square(B)
    let D = Nat.mul(Nat.2)(ecdsa.sub(Nat.square(Nat.add(p.x)(B)))(Nat.add(A)(C)))
    let E = Nat.mul(Nat.3)(A)
    let F = Nat.square(E)
    let F = Nat.square(E)
    let x = ecdsa.sub(F)(Nat.mul(Nat.2)(D))
    let y = ecdsa.sub(Nat.mul(E)(ecdsa.sub(D)(x)))(Nat.mul(Nat.8)(C))
    let z = ecdsa.mod(Nat.mulVar(Nat.3)(Nat.2)(p.y)(p.z))
    Jacobian.new(x)(y)(z);

Jacobian.add: Jacobian -> Jacobian -> Jacobian
  (p) (q)
  p<() Jacobian>
  | (p.x) (p.y) (p.z)
    Bool.or(Nat.eql(p.x)(Nat.0))(Nat.eql(p.y)(Nat.0))<() Jacobian>
    | q;
    | q<() Jacobian>
      | (q.x) (q.y) (q.z)
        Bool.or(Nat.eql(q.x)(Nat.0))(Nat.eql(q.y)(Nat.0))<() Jacobian>
        | p;
        |
          let p.z2 = Nat.square(p.z)
          let q.z2 = Nat.square(q.z)
          let U1 = Nat.mul(p.x)(q.z2)
          let U2 = Nat.mul(q.x)(p.z2)
          let S1 = Nat.mulVar(Nat.3)(p.y)(q.z)(q.z2)
          let S2 = Nat.mulVar(Nat.3)(q.y)(p.z)(p.z2)
          let H = ecdsa.sub(U2)(U1)
          let r = ecdsa.sub(S2)(S1)
          // H = 0 meaning it's the same point.
          Nat.eql(H)(Nat.0)<() Jacobian>
          | Nat.eql(r)(Nat.0)<() Jacobian>
            | Jacobian.double(p);
            | Jacobian.0;;
          | let HH = ecdsa.mod(Nat.square(H))
            let HHH = ecdsa.mod(Nat.mul(H)(HH))
            let V = Nat.mul(U1)(HH)
            let x = ecdsa.sub(ecdsa.sub(Nat.square(r))(HHH))(Nat.mul(Nat.2)(V))
            let y = ecdsa.sub(Nat.mul(r)(ecdsa.sub(V)(x)))(Nat.mul(S1)(HHH))
            let z = ecdsa.mod(Nat.mulVar(Nat.3)(p.z)(q.z)(H))
            Jacobian.new(x)(y)(z);;;;;
