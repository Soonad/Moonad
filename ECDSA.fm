// Params: a, b
CURVE.a: Nat
  0

CURVE.b: Nat
  7

// Field over which we'll do calculations
CURVE.P: Nat
  Nat.parse_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")

// Subgroup order aka prime_order
CURVE.n: Nat
  Nat.parse_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")

// Cofactor
CURVE.h: Nat
  Nat.parse_hex("1")

// Base point (x, y) aka generator point
CURVE.Gx: Nat
  Nat.parse_hex("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798")

CURVE.Gy: Nat
  Nat.parse_hex("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8")

// For endomorphism, see below.
CURVE.beta: Nat
  Nat.parse_hex("7AE96A2B657C07106E64479EAC3434E99CF0497512F58995C1396C28719501EE")

ecdsa.mod(a: Nat): Nat
  Nat.mod(a, CURVE.P)

ecdsa.negate(a: Nat): Nat
  let a = ecdsa.mod(a)
  case Nat.eql(a, 0):
  | 0;
  | Nat.sub(CURVE.P, a);

ecdsa.sub(a: Nat, b: Nat): Nat
  ecdsa.mod(Nat.add(a, ecdsa.negate(b)))

ecdsa.pow_mod(a: Nat, b: Nat, modulo: Nat): Nat
  ecdsa.pow_mod.aux(a, b, modulo, 1)

ecdsa.pow_mod.aux(a: Nat, b: Nat, modulo: Nat, res: Nat): Nat
  case Nat.eql(b, 0):
  | res;
  | let res = Bool.if<>(Nat.odd(b), Nat.mod(Nat.mul(res, a), modulo), res)
    let b = Nat.div(b, 2)
    let a = Nat.mod(Nat.mul(a, a), modulo)
    ecdsa.pow_mod.aux(a, b, modulo, res);

ecdsa.sqrt(a: Nat): Nat
  ecdsa.pow_mod(a, Nat.div(Nat.add(CURVE.P, 1), 4), CURVE.P)

// RHS of elliptic curve equation
ecdsa.weierstrass(x: Nat): Nat
  ecdsa.mod(Nat.add(Nat.add(Nat.mulVar(3, x, x, x), Nat.mul(CURVE.a, x)), CURVE.b))

ecdsa.PRIME_SIZE: Nat
  256

ecdsa.USE_ENDOMORPHISM: Bool
  Nat.eql(CURVE.a, 0)

ecdsa.invert(number: Nat, modulo: Nat): Nat
  case Nat.eql(number, 0):
  | 0;
  | get gcd p = Nat.egcd(Nat.mod(number, modulo), modulo)
    case Nat.eql(gcd, 1):
    | get x y = p
      Int.mod_Nat(x, modulo);
    | 0;;

ecdsa.invertBatch(nums: List(Nat), modulo: Nat): List(Nat)
  get acc p = ecdsa.invertBatch.aux1(nums, modulo, 1, List.nil<Nat>, List.nil<Nat>)
  get scratch rest = p
  let acc = ecdsa.invert(acc, modulo)
  ecdsa.invertBatch.aux2(rest, modulo, acc, scratch, List.nil<Nat>)

ecdsa.invertBatch.aux1(nums: List(Nat), modulo: Nat, acc: Nat, scratch: List(Nat), rest: List(Nat)): Pair(Nat, Pair(List(Nat), List(Nat)))
  case nums:
  | Pair.new<,>(acc, Pair.new<,>(scratch, rest));
  | case Nat.eql(nums.head, 0):
    | let scratch = List.cons<>(0, scratch)
      let rest = List.cons<>(nums.head, rest)
      ecdsa.invertBatch.aux1(nums.tail, modulo, acc, scratch, rest);
    | let scratch = List.cons<>(acc, scratch)
      let acc = Nat.mod(Nat.mul(acc, nums.head), modulo)
      let rest = List.cons<>(nums.head, rest)
      ecdsa.invertBatch.aux1(nums.tail, modulo, acc, scratch, rest);;

ecdsa.invertBatch.aux2(nums: List(Nat), modulo: Nat, acc: Nat, scratch: List(Nat), inverts: List(Nat)): List(Nat)
  case nums:
  | inverts;
  | case scratch:
    | inverts; // Should not happen
    | case Nat.eql(nums.head, 0):
      | let inverts = List.cons<>(0, inverts)
        ecdsa.invertBatch.aux2(nums.tail, modulo, acc, scratch.tail, inverts);
      | let inverts = List.cons<>(Nat.mod(Nat.mul(acc, scratch.head), modulo), inverts)
        let acc = Nat.mod(Nat.mul(acc, nums.head), modulo)
        ecdsa.invertBatch.aux2(nums.tail, modulo, acc, scratch.tail, inverts);;;

// Split 256-bit K into 2 128-bit (k1, k2) for which k1 + k2 * lambda = K.
// https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
ecdsa.split_scalar(k: Nat): Pair(Int, Int)
  let k  = Int.fromNat(k)
  let a1 = Int.parse_hex("3086d221a7d46bcde86c90e49284eb15")
  let b1 = Int.parse_hex("e4437ed6010e88286f547fa90abfe4c3")
  let a2 = Int.parse_hex("114ca50f7a8e2f3f657c1108d9d44cfd8")
  let b2 = Int.parse_hex("3086d221a7d46bcde86c90e49284eb15")
  let c1 = Int.div_Nat(Int.mul(b2, k), CURVE.n)
  let c2 = Int.div_Nat(Int.mul(b1, k), CURVE.n)
  let k1 = Int.sub(Int.sub(k, Int.mul(c1, a1)), Int.mul(c2, a2))
  let k2 = Int.sub(Int.mul(c1, b1), Int.mul(c2, b2))
  Pair.new<Int, Int>(k1, k2)

ecdsa.number_to_hex(num: Nat): String
  let hex = Nat.to_string_base(num, 16);
  Bool.if<>(Nat.odd(String.length(hex)), String.cons('0', hex), hex)

ecdsa.parse_byte(str: String): Nat
  Nat.mul(2, Nat.parse_hex(str))

ecdsa.truncateHash(hash: String): Nat
  let msg = Nat.parse_hex(hash)
  let delta = Nat.sub(Nat.mul(Nat.div(String.length(hash), 2), 8), ecdsa.PRIME_SIZE)
  let msg = Bool.if<>(Nat.gtn(delta, 0), Nat.div(msg, Nat.pow(2, delta)), msg)
  let msg = Bool.if<>(Nat.gte(msg, CURVE.n), Nat.sub(msg, CURVE.n), msg)
  msg

// Jacobian works in jacobi coordinates: (x, y, z) ~ (x/z^2, y/z^3)
T Jacobian
| Jacobian.new(x: Nat, y: Nat, z: Nat);

Jacobian.0: Jacobian
  Jacobian.new(0, 0, 1)

Jacobian.base: Jacobian
  Jacobian.new(CURVE.Gx, CURVE.Gy, 1)

Jacobian.base.window_size: Nat
  8

Jacobian.base.precomputes: List(Jacobian)
  Jacobian.normalizeZ_batch(Jacobian.precompute_window(Jacobian.base, Jacobian.base.window_size))

Jacobian.base.mul(n: Nat): Jacobian
  Jacobian.mul(n, Jacobian.base.window_size, Jacobian.base.precomputes)

Jacobian.base.mul_unsafe(n: Nat): Jacobian
  Jacobian.mul_unsafe(Jacobian.base, n)

Jacobian.equal(a: Jacobian, b: Jacobian): Bool
  get a.x a.y a.z = a
  get b.x b.y b.z = b
  let a.z2 = ecdsa.mod(Nat.mul(a.z, a.z))
  let a.z3 = ecdsa.mod(Nat.mul(a.z, a.z2))
  let b.z2 = ecdsa.mod(Nat.mul(b.z, b.z))
  let b.z3 = ecdsa.mod(Nat.mul(b.z, b.z2))
  let eq1 = Nat.eql(ecdsa.mod(Nat.mul(a.x, b.z2)), ecdsa.mod(Nat.mul(b.x, a.z2)))
  let eq2 = Nat.eql(ecdsa.mod(Nat.mul(a.y, b.z3)), ecdsa.mod(Nat.mul(b.y, a.z3)))
  Bool.and(eq1, eq2)

Jacobian.from_point(p: Point): Jacobian
  get p.x p.y = p
  Jacobian.new(p.x, p.y, 1)

Jacobian.to_point(p: Jacobian): Point
  get p.x p.y p.z = p
  Jacobian.to_point.aux(p, ecdsa.invert(p.z, CURVE.P))

Jacobian.to_point.aux(p: Jacobian, invz: Nat): Point
  get p.x p.y p.z = p
  let invz2 = Nat.square(invz)
  let x = ecdsa.mod(Nat.mul(p.x, invz2))
  let y = ecdsa.mod(Nat.mulVar(3, p.y, invz2, invz))
  Point.new(x, y)

Jacobian.to_pointBatch(ps: List(Jacobian)): List(Point)
  let inverts = ecdsa.invertBatch(List.map<Jacobian, Nat>((p)
    get p.x p.y p.z = p
    p.z, ps), CURVE.P)
  Jacobian.to_pointBatch.aux(ps, inverts)

Jacobian.to_pointBatch.aux(ps: List(Jacobian), inverts: List(Nat)): List(Point)
  case ps:
  | List.nil<>;
  | case inverts:
    | List.nil<>; // should not happen
    | let point = Jacobian.to_point.aux(ps.head, inverts.head)
      List.cons<>(point, Jacobian.to_pointBatch.aux(ps.tail, inverts.tail));;

Jacobian.normalizeZ(p: Jacobian): Jacobian
  Jacobian.from_point(Jacobian.to_point(p))

Jacobian.normalizeZ_batch(p: List(Jacobian)): List(Jacobian)
  List.map<,>(Jacobian.from_point, Jacobian.to_pointBatch(p))

Jacobian.negate(p: Jacobian): Jacobian
  get p.x p.y p.z = p
  Jacobian.new(p.x, ecdsa.negate(p.y), p.z)

Jacobian.double(p: Jacobian): Jacobian
  get p.x p.y p.z = p
  let A = Nat.square(p.x)
  let B = Nat.square(p.y)
  let C = Nat.square(B)
  let D = Nat.mul(2, ecdsa.sub(Nat.square(Nat.add(p.x, B)), Nat.add(A, C)))
  let E = Nat.mul(3, A)
  let F = Nat.square(E)
  let F = Nat.square(E)
  let x = ecdsa.sub(F, Nat.mul(2, D))
  let y = ecdsa.sub(Nat.mul(E, ecdsa.sub(D, x)), Nat.mul(8, C))
  let z = ecdsa.mod(Nat.mulVar(3, 2, p.y, p.z))
  Jacobian.new(x, y, z)

Jacobian.add(p: Jacobian, q: Jacobian): Jacobian
  get p.x p.y p.z = p
  case Bool.or(Nat.eql(p.x, 0), Nat.eql(p.y, 0)):
  | q;
  | get q.x q.y q.z = q
    case Bool.or(Nat.eql(q.x, 0), Nat.eql(q.y, 0)):
    | p;
    | let p.z2 = Nat.square(p.z)
      let q.z2 = Nat.square(q.z)
      let U1 = Nat.mul(p.x, q.z2)
      let U2 = Nat.mul(q.x, p.z2)
      let S1 = Nat.mulVar(3, p.y, q.z, q.z2)
      let S2 = Nat.mulVar(3, q.y, p.z, p.z2)
      let H = ecdsa.sub(U2, U1)
      let r = ecdsa.sub(S2, S1)
      // H = 0 meaning it's the same point.
      case Nat.eql(H, 0):
      | case Nat.eql(r, 0):
        | Jacobian.double(p);
        | Jacobian.0;;
      | let HH = ecdsa.mod(Nat.square(H))
        let HHH = ecdsa.mod(Nat.mul(H, HH))
        let V = Nat.mul(U1, HH)
        let x = ecdsa.sub(ecdsa.sub(Nat.square(r), HHH), Nat.mul(2, V))
        let y = ecdsa.sub(Nat.mul(r, ecdsa.sub(V, x)), Nat.mul(S1, HHH))
        let z = ecdsa.mod(Nat.mulVar(3, p.z, q.z, H))
        Jacobian.new(x, y, z);;;

    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
Jacobian.mul_unsafe(d: Jacobian, scalar: Nat): Jacobian
  let n = Nat.mod(scalar, CURVE.n)
  get k1 k2 = ecdsa.split_scalar(n)
  get k1neg k1 = Int.toNat(k1)
  get k2neg k2 = Int.toNat(k2)
  get k1p k2p = Jacobian.mul_unsafe_aux(d, Jacobian.0, Jacobian.0, k1, k2)
  let k1p = Bool.if<>(k1neg, Jacobian.negate(k1p), k1p)
  let k2p = Bool.if<>(k2neg, Jacobian.negate(k2p), k2p)
  let k2p = get k2p.x k2p.y k2p.z = k2p
    Jacobian.new(ecdsa.mod(Nat.mul(k2p.x, CURVE.beta)), k2p.y, k2p.z)
  Jacobian.add(k1p, k2p)

Jacobian.mul_unsafe_aux(d: Jacobian, k1p: Jacobian, k2p: Jacobian, k1: Nat, k2: Nat): Pair(Jacobian, Jacobian)
  case Bool.or(Nat.gtn(k1, 0), Nat.gtn(k2, 0)):
  | let k1p = Bool.if<>(Nat.odd(k1), Jacobian.add(k1p, d), k1p)
    let k2p = Bool.if<>(Nat.odd(k2), Jacobian.add(k2p, d), k2p)
    let d = Jacobian.double(d)
    let k1 = Nat.div(k1, 2)
    let k2 = Nat.div(k2, 2)
    Jacobian.mul_unsafe_aux(d, k1p, k2p, k1, k2);
  | Pair.new<Jacobian, Jacobian>(k1p, k2p);

ecdsa.window(n: Nat): Nat
  case ecdsa.USE_ENDOMORPHISM:
  | Nat.add(2, Nat.div(Nat.parse_decimal("128"), n));
  | Nat.add(1, Nat.div(Nat.parse_decimal("256"), n));

ecdsa.size(n: Nat): Nat
  Nat.mul(ecdsa.window(n), Nat.pow(2, Nat.pred(n)))

//Jacobian.precompute_window: Jacobian -> (w: Nat) -> Vector(Jacobian, ecdsa.size(w))
Jacobian.precompute_window(p: Jacobian, w: Nat): List(Jacobian)
  let windows = ecdsa.window(w)
  let points = Concat.empty<Jacobian>
  let size = Nat.pow(2, Nat.pred(w))
  Concat.to_list<>(Jacobian.precompute_window.aux(p, windows, points, 0, Jacobian.0, size, 0))

Jacobian.precompute_window.aux(p: Jacobian, windows: Nat, points: Concat(Jacobian), window: Nat, base: Jacobian, size: Nat, i: Nat): Concat(Jacobian)
  case Nat.ltn(window, windows):
  | case Nat.ltn(i, size):
    | let base = Jacobian.add(base, p)
      let points = Concat.push<Jacobian>(base, points)
      Jacobian.precompute_window.aux(p, windows, points, window, base, size, Nat.succ(i));
    | let p = Jacobian.double(base)
      Jacobian.precompute_window.aux(p, windows, points, Nat.succ(window), Jacobian.0, size, 0);;
  | points;

Jacobian.wNAF(W: Nat, precomputes: List(Jacobian), n: Nat): Pair(Jacobian, Jacobian)
  let windows = ecdsa.window(W)
  let windowSize = Nat.pow(2, Nat.pred(W))
  let maxNumber = Nat.pow(2, W)

  // Create mask with W ones: 0b1111 for W=4 etc.
  let mask = Nat.pred(Nat.pow(2, W))

  // real and fake points
  let p = Jacobian.0
  let f = Jacobian.0

  Jacobian.wNAF.aux(precomputes, p, f, n, W, 0, windows, windowSize, mask, maxNumber)

Jacobian.wNAF.aux(precomputes: List(Jacobian), p: Jacobian, f: Jacobian, n: Nat, W: Nat, window: Nat, windows: Nat, windowSize: Nat, mask: Nat, maxNumber: Nat): Pair(Jacobian, Jacobian)
  case Nat.ltn(window, windows):
  | let offset = Nat.mul(window, windowSize)

    // Extract W bits.
    let wbits = Nat.bitwise_and(n, mask)

    // Shift number by W bits.
    let n = Nat.div(n, maxNumber)

    // If the bits are bigger than max size, we'll split those.
    // +224 => 256 - 32
    get n wbits =
      case Nat.gtn(wbits, windowSize):
      | Pair.new<,>(Nat.succ(n), Int.new(wbits, maxNumber));
      | Pair.new<,>(n, Int.fromNat(wbits));

    // Check if we're onto Zero point.
    // Add random point inside current window to f.
    case Int.eql(wbits, Int.0):
    | // List.at should not return none. TODO: Use vector with known size instead of list for precomputes
      let q = Maybe.extract<>(List.at<>(precomputes, offset), Jacobian.0)
      let f = Jacobian.add(f, Bool.if<>(Nat.odd(window), Jacobian.negate(q), q))
      let window = Nat.succ(window)
      Jacobian.wNAF.aux(precomputes, p, f, n, W, window, windows, windowSize, mask, maxNumber) ;
    | // List.at should not return none. TODO: Use vector with known size instead of list for precomputes
      get neg wbits = Int.toNat(wbits)
      let cached = Maybe.extract<>(List.at<>(precomputes, Nat.pred(Nat.add(offset, wbits))), Jacobian.0)
      let cached = Bool.if<>(neg, Jacobian.negate(cached), cached)
      let p = Jacobian.add(p, cached)
      let window = Nat.succ(window)
      Jacobian.wNAF.aux(precomputes, p, f, n, W, window, windows, windowSize, mask, maxNumber);;
  | Pair.new<Jacobian, Jacobian>(p, f);

Jacobian.mul(scalar: Nat, w: Nat, precomputes: List(Jacobian)): Jacobian
  let n = Nat.mod(scalar, CURVE.n)
  get k1 k2 = ecdsa.split_scalar(n)
  get k1neg k1 = Int.toNat(k1)
  get k2neg k2 = Int.toNat(k2)
  get k1p f1p = Jacobian.wNAF(w, precomputes, k1)
  get k2p f2p = Jacobian.wNAF(w, precomputes, k2)
  let k1p = Bool.if<>(k1neg, Jacobian.negate(k1p), k1p)
  let k2p = Bool.if<>(k2neg, Jacobian.negate(k2p), k2p)
  let k2p = get k2p.x k2p.y k2p.z = k2p
    Jacobian.new(ecdsa.mod(Nat.mul(k2p.x, CURVE.beta)), k2p.y, k2p.z)
  let point = Jacobian.add(k1p, k2p)
  let fake  = Jacobian.add(f1p, f2p)
  get _ _ _ = fake // This is used to force the computation of the fake point, to achieve constant time
  Jacobian.normalizeZ(point)

// Point works in default coordinates. Public keys are represented by points.
T Point
| Point.new(x: Nat, y: Nat);

Point.base: Point
  Point.new(CURVE.Gx, CURVE.Gy)

Point.base.mul(n: Nat): Point
  Jacobian.to_point(Jacobian.base.mul(n))

Point.mul_unsafe(p: Point, n: Nat): Point
  Jacobian.to_point(Jacobian.mul_unsafe(Jacobian.from_point(p), n))

Point.valid_point(p: Point): Maybe(Point)
  get x y = p
  case Bool.or(Nat.eql(x, 0), Nat.eql(y, 0)):
  | Maybe.none<>;
  | case Nat.eql(ecdsa.mod(Nat.square(y)), ecdsa.weierstrass(x)):
    | Maybe.some<>(p);
    | Maybe.none<>;;

Point.from_compressed_bytes(bytes: Vector(U8, 33)): Maybe(Point)
  get head tail = Vector.extract<U8, 32>(bytes)
  let head = U8.to_nat(head)
  let x = U8_Vector.to_number<32>(tail)
  let sqrY = ecdsa.weierstrass(x)
  let y = ecdsa.sqrt(sqrY)
  let is_head_odd = Nat.odd(head)
  let is_y_odd = Nat.odd(y)
  let y = Bool.if<>(Bool.eql(is_head_odd, is_y_odd), y, ecdsa.negate(y))
  let point = Point.new(x, y)
  Point.valid_point(point)

Point.from_uncompressed_bytes(bytes: Vector(U8, 65)): Maybe(Point)
  get head tail = Vector.extract<U8, 64>(bytes)
  get x y = Vector.split_at<U8, 64>(tail, 32)
  let x = U8_Vector.to_number<32>(x)
  let y = U8_Vector.to_number<32>(y)
  let point = Point.new(x, y)
  Point.valid_point(point)

Point.to_bytes(p: Point, compressed: Bool): Vector(U8, Bool.if<Nat>(compressed, 33, 65))
 get p.x p.y = p
 let x = U8_Vector.from_nat(32, p.x)
 case compressed:
 | let is_odd_byte = U8.from_nat(Bool.if<Nat>(Nat.odd(p.y), 3, 2))
   Vector.ext<U8, 32>(is_odd_byte, x);
 | let uncompressed_byte = U8.from_nat(4)
   let y = U8_Vector.from_nat(32, p.y)
   let uncompressed_vec = Vector.concat<U8, 32, 32>(x, y)
   Vector.ext<U8, 64>(uncompressed_byte, uncompressed_vec);
 : Vector(U8, Bool.if<Nat>(compressed.self, 33, 65));

Point.from_hex(str: String): Maybe(Point)
  get len bytes = U8_Vector.from_hex(str)
  case Nat.equal(33, len):
  | case self.value as eq:
    with bytes : Vector(U8, eq.b) = bytes;
    | Point.from_compressed_bytes(bytes);;
  | case Nat.equal(65, len):
    | case self.value as eq:
      with bytes : Vector(U8, eq.b) = bytes;
      | Point.from_uncompressed_bytes(bytes);;
    | Maybe.none<>;;

Point.to_hex(p: Point, compressed: Bool): String
  def size = Bool.if<>(compressed, 33, 65)
  U8_Vector.to_hex<size>(Point.to_bytes(p, compressed))

Point.from_SignResult(msgHash: String, sign: SignResult, recovery: Nat): Maybe(Point)
  get r s = sign
  case Bool.or(Nat.eql(r, 0), Nat.eql(s, 0)):
  | Maybe.none<>;
  | let rinv = ecdsa.invert(r, CURVE.n)
    let h = Nat.parse_hex(msgHash)
    let header = U8.from_nat(Nat.add(2, Nat.bitwise_and(recovery, 1)))
    let bytes = Vector.ext<U8, 32>(header, U8_Vector.from_nat(32, r))
    use P_ = Maybe.bind<,>(Point.from_compressed_bytes(bytes))
    let sP = Jacobian.mul_unsafe(Jacobian.from_point(P_), s)
    let hG = Jacobian.negate(Jacobian.base.mul(h))
    let Q = Jacobian.mul_unsafe(Jacobian.add(sP, hG), rinv)
    let point = Jacobian.to_point(Q)
    Point.valid_point(point);

Point.from_PrivateKey(n: Nat): Point
  Point.base.mul(n)

PrivateKey.is_valid(n: Nat): Bool
  Bool.and(Nat.gtn(0, n), Nat.gtn(n, CURVE.n))

PublicKey.from_PrivateKey(priv: Nat, compressed: Bool): Vector(U8, Bool.if<Nat>(compressed, 33, 65))
    let point = Point.from_PrivateKey(priv)
    Point.to_bytes(point, compressed)

PublicKey.recover(msgHash: String, signature: SignResult, recovery: Nat): Maybe(String)
  let point = Point.from_SignResult(msgHash, signature, recovery)
  Maybe.map<,>((p) Point.to_hex(p, Bool.false), point)

T SignResult
| SignResult.new(r: Nat, s: Nat);

SignResult.from_hex(str: String): Maybe(SignResult)
  use pair = Maybe.bind<,>(String.take_n(2, str))
  get str check1 = pair

  use pair = Maybe.bind<,>(String.take_n(2, str))
  get length str = pair
  let length = ecdsa.parse_byte(length)

  use pair = Maybe.bind<,>(String.take_n(2, str))
  get check2 str = pair
  case Bool.orVar(3)(
    String.eql(check1, "30"),
    Nat.eql(length, Nat.sub(String.length(str), 4)),
    String.eql(check2, "02")):
  | Maybe.none<SignResult>;
  | // r
    use pair = Maybe.bind<,>(String.take_n(2, str))
    get rLen str = pair
    let rLen = ecdsa.parse_byte(rLen)
    use pair = Maybe.bind<,>(String.take_n(rLen, str))
    get r str = pair
    let r = Nat.parse_hex(r)
    // s
    use pair = Maybe.bind<,>(String.take_n(2, str))
    get check3 str = pair
    case String.eql(check3, "02"):
    | Maybe.none<SignResult>;
    | use pair = Maybe.bind<,>(String.take_n(2, str))
      get sLen str = pair
      let sLen = ecdsa.parse_byte(sLen)
      use pair = Maybe.bind<,>(String.take_n(sLen, str))
      get s str = pair
      let s = Nat.parse_hex(s)
      Maybe.some<SignResult>(SignResult.new(r, s));;

SignResult.to_hex(sig: SignResult, compressed: Bool): String
  get sig.r sig.s = sig
  let s_hex = ecdsa.number_to_hex(sig.s)
  case compressed:
  | s_hex;
  | let r_hex = ecdsa.number_to_hex(sig.r)
    let r_len_nat = Nat.div(String.length(r_hex), 2)
    let r_len = ecdsa.number_to_hex(r_len_nat)
    let s_len_nat = Nat.div(String.length(s_hex), 2)
    let s_len = ecdsa.number_to_hex(s_len_nat)
    let length = ecdsa.number_to_hex(Nat.addVar(3, r_len_nat, s_len_nat, 4))
    String.concatVar(8, "30", length, "02", r_len, r_hex, "02", s_len, s_hex);

U8_Vector.to_number<n: Nat>(bytes: Vector(U8, n)): Nat
  U8_Vector.to_number.aux<n>(bytes, 0)

U8_Vector.to_number.aux<n: Nat>(bytes: Vector(U8, n), res: Nat): Nat
  case bytes:
  | res;
  | U8_Vector.to_number.aux<bytes.size>(bytes.tail, Nat.add(U8.to_nat(bytes.head), Nat.mul(res, 16)));

U8_Vector.from_nat(pad: Nat, n: Nat): Vector(U8, pad)
  Vector.reverse<U8, pad>(U8_Vector.from_nat(pad, n))

U8_Vector.from_nat.aux(pad: Nat, n: Nat): Vector(U8, pad)
  case pad:
  | Vector.nil<U8>;
  | get div mod = Nat.div_mod(n, 256)
    Vector.ext<U8, pad.pred>(U8.from_nat(mod), U8_Vector.from_nat.aux(pad.pred, div));
  : Vector(U8, pad.self);

U8_Vector.to_hex<n: Nat>(bytes: Vector(U8, n)): String
  case bytes:
  | String.nil;
  | String.concat(ecdsa.number_to_hex(U8.to_nat(bytes.head)), U8_Vector.to_hex<bytes.size>(bytes.tail));

U8_Vector.from_hex(hex: String): Sigma(Nat, Vector(U8))
  case hex:
  | Sigma.new<Nat,Vector(U8)>(0, Vector.nil<U8>);
  | case hex.tail:
    | let b = ecdsa.parse_byte(String.consVar(1, hex.head))
      let vec = Vector.ext<U8,0>(U8.from_nat(b), Vector.nil<U8>)
      Sigma.new<Nat, Vector(U8)>(1, vec);
    | let b = ecdsa.parse_byte(String.consVar(2, hex.head, hex.tail.head))
      get len vec = U8_Vector.from_hex(hex.tail.tail)
      let vec = Vector.ext<U8,len>(U8.from_nat(b), vec)
      Sigma.new<Nat, Vector(U8)>(Nat.succ(len), vec);;

ecdsa.is_valid_private_key(priv_key: Nat): Bool
  Bool.and(Nat.ltn(0, priv_key), Nat.ltn(priv_key, CURVE.n))

T QRS
| QRS.new(p: Point, r: Nat, s: Nat);

QRS.from_k(k: Nat, msg: Nat, priv: Nat): Maybe(QRS)
  let max = CURVE.n
  let q = Point.base.mul(k)
  get q.x q.y = q
  let r = Nat.mod(q.x, max)
  let s = Nat.mod(Nat.mul(ecdsa.invert(k, max), (Nat.add(msg, Nat.mul(r, priv)))), max)
  case Bool.or(Nat.eql(r, 0), Nat.eql(s, 0)):
  | Maybe.none<>;
  | Maybe.some<>(QRS.new(q, r, s));
