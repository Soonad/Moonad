// Params: a, b
CURVE.a: Nat
  Nat.0

CURVE.b: Nat
  Nat.7

// Field over which we'll do calculations
CURVE.P: Nat
  Nat.parse_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")

// Subgroup order aka prime_order
CURVE.n: Nat
  Nat.parse_hex("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")

// Cofactor
CURVE.h: Nat
  Nat.parse_hex("1")

// Base point (x, y) aka generator point
CURVE.Gx: Nat
  Nat.parse_hex("79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798")

CURVE.Gy: Nat
  Nat.parse_hex("483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8")

// For endomorphism, see below.
CURVE.beta: Nat
  Nat.parse_hex("7AE96A2B657C07106E64479EAC3434E99CF0497512F58995C1396C28719501EE")

ecdsa.mod: Nat -> Nat
  (a) Nat.mod(a)(CURVE.P)

ecdsa.P_DIV4_1: Nat
  Nat.div(Nat.add(CURVE.P)(Nat.1))(Nat.4)

// RHS of elliptic curve equation
ecdsa.weistrass: Nat -> Nat
  (x)
  ecdsa.mod(Nat.add(Nat.add(Nat.pow(x)(Nat.3))(Nat.mul(CURVE.a)(x)))(CURVE.b))

ecdsa.PRIME_SIZE: Nat
  Nat.parse_decimal("256")

ecdsa.USE_ENDOMORPHISM: Bool
  Nat.eql(CURVE.a)(Nat.0)

Point: Type
  Pair(Nat)(Nat)

Point.new: Nat -> Nat -> Point
  (x) (y) Pair.new<Nat><Nat>(x)(y)

// Jacobian point works in jacobi coordinates: (x, y, z) ~ (x/z^2, y/z^3)
Jacobian: Type
  jacobian<P: Jacobian -> Type> ->
  (new: (x: Nat) -> (y: Nat) -> (z: Nat)-> P(Jacobian.new(x)(y)(z))) ->
  P(jacobian)

Jacobian.new: Nat -> Nat -> Nat -> Jacobian
  (x) (y) (z)
  <P> (point) point(x)(y)(z)

Jacobian.equal: Jacobian -> Jacobian -> Bool
  (a) (b)
  a<() Bool>
  | (a.x) (a.y) (a.z)
    b<() Bool>
    | (b.x) (b.y) (b.z)
      let a.z2 = ecdsa.mod(Nat.mul(a.z)(a.z))
      let a.z3 = ecdsa.mod(Nat.mul(a.z)(a.z2))
      let b.z2 = ecdsa.mod(Nat.mul(b.z)(b.z))
      let b.z3 = ecdsa.mod(Nat.mul(b.z)(b.z2))
      let eq1 = Nat.eql(ecdsa.mod(Nat.mul(a.x)(b.z2)))(ecdsa.mod(Nat.mul(b.x)(a.z2)))
      let eq2 = Nat.eql(ecdsa.mod(Nat.mul(a.y)(b.z3)))(ecdsa.mod(Nat.mul(b.y)(a.z3)))
      Bool.and(eq1)(eq2);;

Jacobian.fromPoint: Point -> Jacobian
  (p)
  p<() Jacobian>
  | (p.x) (p.y) Jacobian.new(p.x)(p.y)(Nat.1);