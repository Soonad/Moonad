T Nat
| zero;
| succ(pred: Nat);

Nat.add(n: Nat, m: Nat): Nat
  case n:
  | m;
  | Nat.succ(Nat.add(n.pred, m));

Nat.apply.tco<A: Type>(n: Nat, f: A -> A, x: A): A
  case n:
  | x;
  | Nat.apply.tco<A>(n.pred, f, f(x));

Nat.apply: <A: Type> -> (n: Nat, f: A -> A, x: A) -> A
  Nat.apply.tco

Nat.cmp(a: Nat, b: Nat): Cmp
  case a:
  | case b:
    | Cmp.eql;
    | Cmp.ltn;;
  | case b:
    | Cmp.gtn;
    | Nat.cmp(a.pred, b.pred);;

Nat.sub(n: Nat, m: Nat): Nat
  case n:
  | 0;
  | case m:
    | n;
    | Nat.sub(n.pred, m.pred);;
  // case m:
  // | n;
  // | case n:
  //   | Nat.zero;
  //   | Nat.sub(n.pred, m.pred);;

Nat.sub_rem(n: Nat, m: Nat): Either(Nat, Nat)
  case m:
  | Either.left<_,_>(n);
  | case n:
    | Either.right<_,_>(Nat.succ(m.pred));
    | Nat.sub_rem(n.pred, m.pred);;

Nat.div(n: Nat, m: Nat): Nat
  Pair.fst<_,_>(Nat.div_mod(n, m))

Nat.div_mod.aux(n: Nat, m: Nat, d: Nat): Pair(Nat, Nat)
  let p = Nat.sub_rem(n,m)
  case p:
  | Nat.div_mod.aux(p.value,m,Nat.succ(d));
  | Pair.new<_,_>(d,n);

Nat.div_mod(n: Nat, m: Nat): Pair(Nat, Nat)
  Nat.div_mod.aux(n,m,Nat.zero)

Nat.double(n: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.succ(Nat.succ(Nat.double(n.pred)));

Nat.ltn(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.true;
  | Bool.false;
  | Bool.false;

Nat.lte(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.true;
  | Bool.true;
  | Bool.false;

Nat.eql(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.true;
  | Bool.false;

Nat.gte(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.true;
  | Bool.true;

Nat.gtn(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.false;
  | Bool.true;

Nat.induction(n: Nat): <P: Nat -> Type> -> (z: P(Nat.zero)) -> (s: ((m:Nat) -> P(m) -> P(Nat.succ(m)))) -> P(n)
  <P> (z) (s) n<P>(z, (pred) s(pred, Nat.induction(pred)<P>(z, s)))

Nat.is_zero(n: Nat): Bool
  case n:
  | Bool.true;
  | Bool.false;

Nat.mod(n: Nat, m: Nat): Nat
  Pair.snd<Nat,Nat>(Nat.div_mod(n,m))

Nat.mul(n: Nat, m: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.add(m, Nat.mul(n.pred, m));

//TODO: error on misformatted Nat
Nat.parse_decimal(str: String): Nat
  Nat.parse_decimal.go(str, Nat.zero)

Nat.parse_decimal.go(str: String, res: Nat): Nat
  case str:
  | res;
  | let dig = Nat.sub(U16.to_nat(str.head), 48)
    let res = Nat.add(dig, Nat.mul(10, res))
    Nat.parse_decimal.go(str.tail, res);

Nat.pred(n: Nat): Nat
  case n:
  | Nat.zero;
  | n.pred;

//Nat.solve_for: (x: Nat) -> <E: (x: Nat) -> Type> -> <P: E(x)> -> Nat
  //(x) <E> <P> x

Nat.succ_isnt_zero(n: Nat, e: Equal(Nat, Nat.succ(n), Nat.zero)): Empty
  def P = ((x) case x: | Empty; | Unit;) :: Nat -> Type
  Equal.rewrite<Nat, Nat.succ(n), Nat.zero, P>(e, Unit.new)

Nat.sum(n: Nat): Nat
  Nat.sum.go(n, Nat.zero)

Nat.sum.go(n: Nat , r: Nat): Nat //loop//
  case n:
  | r;
  | Nat.sum.go(n.pred, Nat.add(n, r));

Nat.to_base(base: Nat, nat: Nat): List(Nat)
  Nat.to_base.go(base, nat, List.nil<Nat>)

Nat.to_base.go(base: Nat, nat: Nat, res: List(Nat)): List(Nat) //loop//
  case Nat.div_mod(nat, base) as p:
  | let res = List.cons<Nat>(p.snd, res)
    case p.fst<() List(Nat)>:
    | res;
    | Nat.to_base.go(base, p.fst, res);;

////base(123, [])
////base(12, [3])
////base(1, [2,3])

Nat.to_bits(n: Nat): Bits
  case n:
  | Bits.0(Bits.nil);
  | Bits.1(Nat.to_bits(n.pred));

Nat.to_string(n: Nat): String
  case n:
  | String.cons(Char.parse("z"), String.nil);
  | String.cons(Char.parse("s"), Nat.to_string(n.pred));

Nat.to_string_base(base: Nat, nat: Nat): String
  List.foldr<Nat, String>
  | String.nil;
  | (n) (str) String.cons(Nat.apply<Char>(n, U16.inc, Char.parse("0")), str);
  | Nat.to_base(base, nat);

Nat.to_string_decimal: Nat -> String
  Nat.to_string_base(10)

Nat.show(n: Nat): String
  Nat.to_string_decimal(10)

Nat.addVar: (n: Nat) -> Variadic(n, Nat, Nat)
  Variadic.foldr<,>(Nat.add, 0)

Nat.addAcc: (n: Nat) -> Acc(Nat, Nat, Nat.eql(0), n)
  Acc.foldl<,>(Nat.eql(0), Nat.add, 0)

Nat.mulAcc: (n: Nat) -> Acc(Nat, Nat, Nat.eql(1), n)
  Acc.foldl<,>(Nat.eql(1), Nat.mul, 1)

Nat.mulVar: (n: Nat) -> Variadic(n, Nat, Nat)
  Variadic.foldr<,>(Nat.mul, 1)

Nat.parse_hex:
  (str: String) ->
    Nat.parse_hex_safe(str)<() Type>
    | Unit;
    | () Nat;
  (str)
  Nat.parse_hex_safe(str)<
    (m)
    m<() Type>
    | Unit;
    | () Nat;
  >
  | Unit.new;
  | (val) val;

Nat.parse_hex_safe: String -> Maybe(Nat)
  (str) Nat.parse_hex_safe.go(str, Nat.zero)

Nat.parse_hex_safe.go(str: String, res: Nat): Maybe(Nat)
  case str:
  | Maybe.some<Nat>(res);
  | use dig = Maybe.bind<,>(Char.hex_value(str.head))
    let res = Nat.add(dig, Nat.mul(16, res))
    Nat.parse_hex_safe.go(str.tail, res);

Nat.pow(a: Nat, b: Nat): Nat //prim//
  case b:
  | 1;
  | Nat.mul(a, Nat.pow(a, b.pred));

Nat.square(a: Nat): Nat
  Nat.mul(a, a)

// Extended Euclidian algorithm. Given natural numbers a, b, computes GCD(a,b) and
// Bezout's coefficients; that is, integers x, y such that a*x + b*y = GCD(a,b)
Nat.egcd(a: Nat, b: Nat): Pair(Nat, Pair(Int, Int))
   Nat.egcd.aux(a, b, Int.0, Int.1, Int.1, Int.0)

Nat.egcd.aux(a: Nat, b: Nat, x: Int, y: Int, u: Int, v: Int): Pair(Nat, Pair(Int, Int))
  case a:
  | Pair.new<,>(b, Pair.new<,>(x, y));
  | let q = Nat.div(b, a)
    let r = Nat.mod(b, a)
    let m = Int.sub(x, Int.mul(u, Int.fromNat(q)))
    let n = Int.sub(y, Int.mul(v, Int.fromNat(q)))
    Nat.egcd.aux(r, a, u, v, m, n);

Nat.bitwise_and(a: Nat, b: Nat): Nat
  case Bool.or(Nat.eql(a, 0), Nat.eql(a, 0)):
  | 0;
  | let bit = Bool.if<Nat>(Bool.or(Nat.eql(Nat.mod(a, 2), 0), Nat.eql(Nat.mod(b, 2), 0)), 0, 1)
    let a = Nat.div(a, 2)
    let b = Nat.div(b, 2)
    Nat.add(bit, Nat.mul(2, Nat.bitwise_and(a, b)));

Nat.odd(n: Nat): Bool
  Nat.eql(Nat.mod(n, 2), 1)

Nat.min(a: Nat): Nat -> Nat
  case a:
  | (b) 0;
  | (b)
    case b:
    | 0;
    | Nat.succ(Nat.min(a.pred, b.pred));;

Nat.add_x_0(x: Nat): Equal(Nat, Nat.add(x, 0), x)
  case x:
  | Equal.to<,>;
  | def a = Nat.add(x.pred, 0)
    def b = x.pred
    def eq = Nat.add_x_0(x.pred)
    Equal.apply<_, _, a, b, Nat.succ, eq>;
  : Equal(Nat, Nat.add(x.self, 0), x.self);

Nat.add_x_succ_y(x: Nat, y: Nat): Equal(Nat, Nat.add(x, Nat.succ(y)), Nat.succ(Nat.add(x, y)))
  case x:
  | Equal.to<,>;
  | def a = Nat.add(x.pred, Nat.succ(y))
    def b = Nat.succ(Nat.add(x.pred, y))
    def eq = Nat.add_x_succ_y(x.pred, y)
    Equal.apply<_, _, a, b, Nat.succ, eq>;
  : Equal(Nat, Nat.add(x.self, Nat.succ(y)), Nat.succ(Nat.add(x.self, y)));
