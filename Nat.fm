T Nat
| zero;
| succ(pred: Nat);

Nat.add(n: Nat, m: Nat): Nat
  case n:
  | m;
  | Nat.succ(Nat.add(n.pred, m));

Nat.apply.tco<A: Type>(n: Nat, f: A -> A, x: A): A
  case n:
  | x;
  | Nat.apply.tco<A>(n.pred, f, f(x));

Nat.apply: <A: Type> -> (n: Nat, f: A -> A, x: A) -> A
  Nat.apply.tco

Nat.cmp(a: Nat, b: Nat): Cmp
  case a:
  | case b:
    | Cmp.eql;
    | Cmp.ltn;;
  | case b:
    | Cmp.gtn;
    | Nat.cmp(a.pred, b.pred);;

Nat.sub(n: Nat, m: Nat): Nat
  case m:
  | n;
  | case n:
    | Nat.zero;
    | Nat.sub(n.pred, m.pred);;

Nat.sub_rem(n: Nat, m: Nat): Either(Nat, Nat)
  case m:
  | Either.left<_,_>(n);
  | case n:
    | Either.right<_,_>(Nat.succ(m.pred));
    | Nat.sub_rem(n.pred, m.pred);;

Nat.div(n: Nat, m: Nat): Nat
  Pair.fst<_,_>(Nat.div_mod(n, m))

Nat.div_mod.aux(n: Nat, m: Nat, d: Nat): Pair(Nat, Nat)
  let p = Nat.sub_rem(n,m)
  case p:
  | Nat.div_mod.aux(p.value,m,Nat.succ(d));
  | Pair.new<_,_>(d,n);

Nat.div_mod(n: Nat, m: Nat): Pair(Nat, Nat)
  Nat.div_mod.aux(n,m,Nat.zero)

Nat.double(n: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.succ(Nat.succ(Nat.double(n.pred)));

Nat.ltn(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.true;
  | Bool.false;
  | Bool.false;

Nat.lte(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.true;
  | Bool.true;
  | Bool.false;

Nat.eql(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.true;
  | Bool.false;

Nat.gte(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.true;
  | Bool.true;

Nat.gtn(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.false;
  | Bool.true;

Nat.induction(n: Nat): <P: Nat -> Type> -> (z: P(Nat.zero)) -> (s: ((m:Nat) -> P(m) -> P(Nat.succ(m)))) -> P(n)
  <P> (z) (s) n<P>(z, (pred) s(pred, Nat.induction(pred)<P>(z, s)))

Nat.is_zero(n: Nat): Bool
  case n:
  | Bool.true;
  | Bool.false;

Nat.mod(n: Nat, m: Nat): Nat
  Pair.snd<Nat,Nat>(Nat.div_mod(n,m))

Nat.mul(n: Nat, m: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.add(m, Nat.mul(n.pred, m));

//TODO: error on misformatted Nat
Nat.parse_decimal(str: String): Nat
  Nat.parse_decimal.go(str, Nat.zero)

Nat.parse_decimal.go(str: String, res: Nat): Nat
  case str:
  | res;
  | let dig = Nat.sub(U16.to_nat(str.head), 48)
    let res = Nat.add(dig, Nat.mul(10, res))
    Nat.parse_decimal.go(str.tail, res);

Nat.pred(n: Nat): Nat
  case n:
  | Nat.zero;
  | n.pred;

Nat.show.aux(n: Nat, base: Nat, str: String): String
  (Nat.div_mod(n, base))<() String> | (d) (m)
  d<() String>
  | String.cons(Nat.show.digit(m, base), str);
  | (pred) Nat.show.aux(d, base, String.cons(Nat.show.digit(m, base), str));;

Nat.show.digit(n: Nat, base: Nat): Char
  let m = Nat.mod(n, base)
  case Nat.eql(m, 0):  | Char.parse("0"); |
  case Nat.eql(m, 1):  | Char.parse("1"); |
  case Nat.eql(m, 2):  | Char.parse("2"); |
  case Nat.eql(m, 3):  | Char.parse("3"); |
  case Nat.eql(m, 4):  | Char.parse("4"); |
  case Nat.eql(m, 5):  | Char.parse("5"); |
  case Nat.eql(m, 6):  | Char.parse("6"); |
  case Nat.eql(m, 7):  | Char.parse("7"); |
  case Nat.eql(m, 8):  | Char.parse("8"); |
  case Nat.eql(m, 9):  | Char.parse("9"); |
  case Nat.eql(m, 10): | Char.parse("a"); |
  case Nat.eql(m, 11): | Char.parse("b"); |
  case Nat.eql(m, 12): | Char.parse("c"); |
  case Nat.eql(m, 13): | Char.parse("d"); |
  case Nat.eql(m, 14): | Char.parse("e"); |
  case Nat.eql(m, 15): | Char.parse("f"); |
    Char.parse("#");;;;;;;;;;;;;;;;
   // TODO: use absurd to cancel this case
 // case Nat.eql(m, 16): | Char.parse("g"); |
 // case Nat.eql(m, 17): | Char.parse("h"); |
 // case Nat.eql(m, 18): | Char.parse("i"); |
 // case Nat.eql(m, 19): | Char.parse("j"); |
 // case Nat.eql(m, 20): | Char.parse("k"); |
 // case Nat.eql(m, 21): | Char.parse("l"); |
 // case Nat.eql(m, 22): | Char.parse("m"); |
 // case Nat.eql(m, 23): | Char.parse("n"); |
 // case Nat.eql(m, 24): | Char.parse("o"); |
 // case Nat.eql(m, 25): | Char.parse("p"); |
 // case Nat.eql(m, 26): | Char.parse("q"); |
 // case Nat.eql(m, 27): | Char.parse("r"); |
 // case Nat.eql(m, 28): | Char.parse("s"); |
 // case Nat.eql(m, 30): | Char.parse("t"); |
 // case Nat.eql(m, 31): | Char.parse("u"); |
 // case Nat.eql(m, 32): | Char.parse("v"); |

Nat.show_base: Nat -> Nat -> String
  (n) (base) Nat.show.aux(n, base, "")

Nat.show(n: Nat): String
  Nat.show_base(n, 10)

//Nat.solve_for: (x: Nat) -> <E: (x: Nat) -> Type> -> <P: E(x)> -> Nat
  //(x) <E> <P> x

Nat.succ_isnt_zero(n: Nat, e: Equal(Nat, Nat.succ(n), Nat.zero)): Empty
  def P = ((x) case x: | Empty; | Unit;) :: Nat -> Type
  Equal.rewrite<Nat, Nat.succ(n), Nat.zero, P>(e, Unit.new)

Nat.sum(n: Nat): Nat
  Nat.sum.go(n, Nat.zero)

Nat.sum.go(n: Nat , r: Nat): Nat //loop//
  case n:
  | r;
  | Nat.sum.go(n.pred, Nat.add(n, r));

Nat.to_base(base: Nat, nat: Nat): List(Nat)
  Nat.to_base.go(base, nat, List.nil<Nat>)

Nat.to_base.go(base: Nat, nat: Nat, res: List(Nat)): List(Nat) //loop//
  case Nat.div_mod(nat, base) as p:
  | let res = List.cons<Nat>(p.snd, res)
    case p.fst<() List(Nat)>:
    | res;
    | Nat.to_base.go(base, p.fst, res);;

////base(123, [])
////base(12, [3])
////base(1, [2,3])

Nat.to_bits(n: Nat): Bits
  case n:
  | Bits.0(Bits.nil);
  | Bits.1(Nat.to_bits(n.pred));

Nat.to_string(n: Nat): String
  case n:
  | String.cons(Char.parse("z"), String.nil);
  | String.cons(Char.parse("s"), Nat.to_string(n.pred));

Nat.to_string_base(base: Nat, nat: Nat): String
  List.fold<Nat, String>
  | String.nil;
  | (n) (str) String.cons(Nat.apply<Char>(n, U16.inc, Char.parse("0")), str);
  | Nat.to_base(base, nat);

Nat.to_string_decimal: Nat -> String
  Nat.to_string_base(10)
