// Natural numbers
T Nat
| zero;
| succ(pred: Nat);

// Nat predecessor
Nat.pred(n: Nat): Nat
  case n:
  | Nat.zero;
  | n.pred;

// Nat addition
Nat.add(n: Nat, m: Nat): Nat
  case n:
  | m;
  | Nat.succ(Nat.add(n.pred, m));

// Nat multiplication
Nat.mul(n: Nat, m: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.add(m, Nat.mul(n.pred, m));

// Nat subtraction
Nat.sub(n: Nat, m: Nat): Nat
  case m:
  | n;
  | case n:
    | Nat.zero;
    | Nat.sub(n.pred, m.pred);;

// Nat subtraction and remainder
Nat.sub_rem(n: Nat, m: Nat): Either(Nat, Nat)
  case m:
  | Either.left<_,_>(n);
  | case n:
    | Either.right<_,_>(Nat.succ(m.pred));
    | Nat.sub_rem(n.pred, m.pred);;

// Nat division and remainder (helper function)
Nat.div_mod.go(n: Nat, m: Nat, d: Nat): Pair(Nat, Nat)
  let p = Nat.sub_rem(n,m)
  case p:
  | Nat.div_mod.go(p.value,m,Nat.succ(d));
  | Pair.new<_,_>(d,n);

// Nat division and modulus
Nat.div_mod(n: Nat, m: Nat): Pair(Nat, Nat)
  Nat.div_mod.go(n,m,Nat.zero)

// Nat modulus
Nat.mod(n: Nat, m: Nat): Nat
  Pair.snd<Nat,Nat>(Nat.div_mod(n,m))

// Nat division
Nat.div(n: Nat, m: Nat): Nat
  Pair.fst<_,_>(Nat.div_mod(n, m))

// Compares two nats
Nat.cmp(a: Nat, b: Nat): Cmp
  case a:
  | case b:
    | Cmp.eql;
    | Cmp.ltn;;
  | case b:
    | Cmp.gtn;
    | Nat.cmp(a.pred, b.pred);;

// n < m
Nat.ltn(n: Nat, m: Nat): Bool
  Cmp.as_ltn(Nat.cmp(n, m))

// n <= m
Nat.lte(n: Nat, m: Nat): Bool
  Cmp.as_lte(Nat.cmp(n, m))

// n == m
Nat.eql(n: Nat, m: Nat): Bool
  Cmp.as_eql(Nat.cmp(n, m))

// n >= m
Nat.gte(n: Nat, m: Nat): Bool
  Cmp.as_gte(Nat.cmp(n, m))

// n > m
Nat.gtn(n: Nat, m: Nat): Bool
  Cmp.as_gtn(Nat.cmp(n, m))

Nat.apply.tco<A: Type>(n: Nat, f: A -> A, x: A): A
  case n:
  | x;
  | Nat.apply.tco<A>(n.pred, f, f(x));

Nat.apply: <A: Type> -> (n: Nat, f: A -> A, x: A) -> A
  Nat.apply.tco

Nat.double(n: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.succ(Nat.succ(Nat.double(n.pred)));

Nat.induction(n: Nat): <P: Nat -> Type> -> (z: P(Nat.zero)) -> (s: ((m:Nat) -> P(m) -> P(Nat.succ(m)))) -> P(n)
  <P> (z) (s) n<P>(z, (pred) s(pred, Nat.induction(pred)<P>(z, s)))

Nat.is_zero(n: Nat): Bool
  case n:
  | Bool.true;
  | Bool.false;

//TODO: error on misformatted Nat
Nat.parse_decimal(str: String): Nat
  Nat.parse_decimal.go(str, Nat.zero)

Nat.parse_decimal.go(str: String, res: Nat): Nat
  case str:
  | res;
  | let dig = Nat.sub(U16.to_nat(str.head), 48)
    let res = Nat.add(dig, Nat.mul(10, res))
    Nat.parse_decimal.go(str.tail, res);

//Nat.solve_for: (x: Nat) -> <E: (x: Nat) -> Type> -> <P: E(x)> -> Nat
  //(x) <E> <P> x

Nat.succ_isnt_zero(n: Nat, e: Equal(Nat, Nat.succ(n), Nat.zero)): Empty
  def P = ((x) case x: | Empty; | Unit;) :: Nat -> Type
  Equal.rewrite<Nat, Nat.succ(n), Nat.zero, P>(e, Unit.new)

Nat.sum(n: Nat): Nat
  Nat.sum.go(n, Nat.zero)

Nat.sum.go(n: Nat , r: Nat): Nat //loop//
  case n:
  | r;
  | Nat.sum.go(n.pred, Nat.add(n, r));

Nat.to_base(base: Nat, nat: Nat): List(Nat)
  Nat.to_base.go(base, nat, List.nil<Nat>)

Nat.to_base.go(base: Nat, nat: Nat, res: List(Nat)): List(Nat) //loop//
  case Nat.div_mod(nat, base) as p:
  | let res = List.cons<Nat>(p.snd, res)
    case p.fst<() List(Nat)>:
    | res;
    | Nat.to_base.go(base, p.fst, res);;

////base(123, [])
////base(12, [3])
////base(1, [2,3])

Nat.to_bits(n: Nat): Bits
  case n:
  | Bits.0(Bits.nil);
  | Bits.1(Nat.to_bits(n.pred));

Nat.to_string(n: Nat): String
  case n:
  | String.cons(Char.parse("z"), String.nil);
  | String.cons(Char.parse("s"), Nat.to_string(n.pred));

Nat.to_string_base(base: Nat, nat: Nat): String
  List.foldr<Nat, String>
  | String.nil;
  | (n) (str) String.cons(Nat.apply<Char>(n, U16.inc, Char.parse("0")), str);
  | Nat.to_base(base, nat);

Nat.to_string_decimal: Nat -> String
  Nat.to_string_base(10)

Nat.show(n: Nat): String
  Nat.to_string_decimal(10)
