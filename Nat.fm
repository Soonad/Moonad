T Nat
| zero;
| succ(pred: Nat);

Nat.add(n: Nat, m: Nat): Nat
  case n:
  | m;
  | Nat.succ(Nat.add(n.pred, m));

Nat.apply.tco<A: Type>(n: Nat, f: A -> A, x: A): A
  case n:
  | x;
  | Nat.apply.tco<A>(n.pred, f, f(x));

Nat.apply: <A: Type> -> (n: Nat, f: A -> A, x: A) -> A
  Nat.apply.tco

Nat.cmp(a: Nat, b: Nat): Cmp
  case a:
  | case b:
    | Cmp.eql;
    | Cmp.ltn;;
  | case b:
    | Cmp.gtn;
    | Nat.cmp(a.pred, b.pred);;

Nat.sub(n: Nat, m: Nat): Nat
  case m:
  | n;
  | case n:
    | Nat.zero; 
    | Nat.sub(n.pred)(m.pred);;

Nat.sub_rem(n: Nat, m: Nat): Either(Nat)(Nat)
  case m:
  | Either.left<_,_>(n);
  | case n:
    | Either.right<_,_>(Nat.succ(m.pred));
    | Nat.sub_rem(n.pred)(m.pred);;

Nat.div(n: Nat, m: Nat): Nat
  Pair.fst<_,_>(Nat.div_mod(n, m))

Nat.div_mod.aux(n: Nat, m: Nat, d: Nat): Pair(Nat)(Nat)
  let p = Nat.sub_rem(n,m)
  case p:
  | Nat.div_mod.aux(p.value,m,Nat.succ(d));
  | Pair.new<_,_>(d,n);

Nat.div_mod(n: Nat, m: Nat): Pair(Nat)(Nat)
  Nat.div_mod.aux(n,m,Nat.zero)

Nat.double(n: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.succ(Nat.succ(Nat.double(n.pred)));

Nat.ltn(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.true;
  | Bool.false;
  | Bool.false;

Nat.lte(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.true;
  | Bool.true;
  | Bool.false;

Nat.eql(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.true;
  | Bool.false;

Nat.gte(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.true;
  | Bool.true;

Nat.gtn(n: Nat, m: Nat): Bool
  case Nat.cmp(n, m):
  | Bool.false;
  | Bool.false;
  | Bool.true;

Nat.induction(n: Nat): <P: Nat -> Type> -> (z: P(Nat.zero)) -> (s: ((m:Nat) -> P(m) -> P(Nat.succ(m)))) -> P(n)
  <P> (z) (s) n<P>(z)((pred) s(pred)(Nat.induction(pred)<P>(z)(s)))

Nat.is_zero(n: Nat): Bool
  case n:
  | Bool.true;
  | Bool.false;

Nat.mod(n: Nat, m: Nat): Nat
  Pair.snd<Nat,Nat>(Nat.div_mod(n,m))

Nat.mul(n: Nat, m: Nat): Nat
  case n:
  | Nat.zero;
  | Nat.add(m, Nat.mul(n.pred, m));

// TODO: error on misformatted Nat
//Nat.parse_decimal(str: String): Nat
  //Nat.parse_decimal.go(str, Nat.zero) 

//// TODO: error on misformatted Nat
//Nat.parse_decimal.go: String -> Nat -> Nat //loop//
  //(str) (res)
  //str<() Nat>
  //| res;
  //| (str.head) (str.tail)
    //let dig = Nat.sub(U16.to_nat(str.head))(Nat.48)
    //let res = Nat.add(dig)(Nat.mul(Nat.10)(res))
    //Nat.parse_decimal.go(str.tail)(res);

Nat.pred(n: Nat): Nat
  case n:
  | Nat.zero;
  | n.pred;

//Nat.show.aux: Nat -> Nat -> String -> String
  //(n) (base) (str)
  //(Nat.div_mod(n)(base))<() String> | (d) (m)
  //d<() String>
  //| String.cons(Nat.show.digit(m)(base))(str);
  //| (pred) Nat.show.aux(d)(base)(String.cons(Nat.show.digit(m)(base))(str));;

//Nat.show.digit: Nat -> Nat -> Char
  //(n) (base) 
  //let m = Nat.mod(n)(base)
  //Nat.eql(m)(Nat.0)<() Char> | Char.parse("0"); |
  //Nat.eql(m)(Nat.1)<() Char> | Char.parse("1"); |
  //Nat.eql(m)(Nat.2)<() Char> | Char.parse("2"); |
  //Nat.eql(m)(Nat.3)<() Char> | Char.parse("3"); |
  //Nat.eql(m)(Nat.4)<() Char> | Char.parse("4"); |
  //Nat.eql(m)(Nat.5)<() Char> | Char.parse("5"); |
  //Nat.eql(m)(Nat.6)<() Char> | Char.parse("6"); |
  //Nat.eql(m)(Nat.7)<() Char> | Char.parse("7"); |
  //Nat.eql(m)(Nat.8)<() Char> | Char.parse("8"); |
  //Nat.eql(m)(Nat.9)<() Char> | Char.parse("9"); |
  //Nat.eql(m)(Nat.10)<() Char> | Char.parse("a"); |
  //Nat.eql(m)(Nat.11)<() Char> | Char.parse("b"); |
  //Nat.eql(m)(Nat.12)<() Char> | Char.parse("c"); |
  //Nat.eql(m)(Nat.13)<() Char> | Char.parse("d"); |
  //Nat.eql(m)(Nat.14)<() Char> | Char.parse("e"); |
  //Nat.eql(m)(Nat.15)<() Char> | Char.parse("f"); |
    //Char.parse("#");;;;;;;;;;;;;;;;
    //// TODO: use absurd to cancel this case
////  Nat.eql(m)(Nat.16)<() Char> | Char.parse("g"); |
////  Nat.eql(m)(Nat.17)<() Char> | Char.parse("h"); |
////  Nat.eql(m)(Nat.18)<() Char> | Char.parse("i"); |
////  Nat.eql(m)(Nat.19)<() Char> | Char.parse("j"); |
////  Nat.eql(m)(Nat.20)<() Char> | Char.parse("k"); |
////  Nat.eql(m)(Nat.21)<() Char> | Char.parse("l"); |
////  Nat.eql(m)(Nat.22)<() Char> | Char.parse("m"); |
////  Nat.eql(m)(Nat.23)<() Char> | Char.parse("n"); |
////  Nat.eql(m)(Nat.24)<() Char> | Char.parse("o"); |
////  Nat.eql(m)(Nat.25)<() Char> | Char.parse("p"); |
////  Nat.eql(m)(Nat.26)<() Char> | Char.parse("q"); |
////  Nat.eql(m)(Nat.27)<() Char> | Char.parse("r"); |
////  Nat.eql(m)(Nat.28)<() Char> | Char.parse("s"); |
////  Nat.eql(m)(Nat.30)<() Char> | Char.parse("t"); |
////  Nat.eql(m)(Nat.31)<() Char> | Char.parse("u"); |
////  Nat.eql(m)(Nat.32)<() Char> | Char.parse("v"); |


//Nat.show: Nat -> String
  //(n) Nat.show.aux(n)(Nat.10)("")

//Nat.show_base: Nat -> Nat -> String
  //(n) (base) Nat.show.aux(n)(base)("")

//Nat.solve_for: (x: Nat) -> <E: (x: Nat) -> Type> -> <P: E(x)> -> Nat
  //(x) <E> <P> x

Nat.succ_isnt_zero(n: Nat, e: Equal(Nat)(Nat.succ(n))(Nat.zero)): Empty
  def P = ((x) case x: | Empty; | Unit;) :: Nat -> Type
  Equal.rewrite<Nat><Nat.succ(n)><Nat.zero><P>(e)(Unit.new)

//Nat.sum: Nat -> Nat
  //(n) Nat.sum.tco(n)(Nat.zero)

//Nat.sum.tco: Nat -> Nat -> Nat //loop//
  //(n) (r)
  //n<() Nat>
  //| r;
  //| (n.pred) Nat.sum.tco(n.pred)(Nat.add(n)(r));

//Nat.to_base: Nat -> Nat -> List(Nat)
  //(base) (nat)
  //Nat.to_base.go(base)(nat)(List.nil<Nat>)

//Nat.to_base.go: Nat -> Nat -> List(Nat) -> List(Nat) //loop//
  //(base) (nat) (res)
  //Nat.div_mod(nat)(base)<() List(Nat)>
  //| (div) (rem)
    //let res = List.cons<Nat>(rem)(res)
    //div<() List(Nat)>
    //| res;
    //| (div.pred) Nat.to_base.go(base)(div)(res);;

////base(123, [])
////base(12, [3])
////base(1, [2,3])

//Nat.to_bits: Nat -> Bits
  //(n)
  //n<() Bits>
  //| Bits.0(Bits.nil);
  //| (n.pred) Bits.1(Nat.to_bits(n.pred));

//Nat.to_string: Nat -> String
  //(n)
  //n<() String>
  //| String.cons(Char.parse("z"))(String.nil);
  //| (n.pred) String.cons(Char.parse("s"))(Nat.to_string(n.pred));

//Nat.to_string_base: Nat -> Nat -> String
  //(base) (nat)
  //List.fold<Nat><String>
  //| String.nil;
  //| (n) (str) String.cons(Nat.apply<Char>(n)(U16.inc)(Char.parse("0")))(str);
  //| Nat.to_base(base)(nat);

//Nat.to_string_decimal: Nat -> String
  //Nat.to_string_base(Nat.10)
