// A monomorphic specialization of List(Char) for performance/compilation
T String
| nil;
| cons(head: Char, tail: String);

// Basic Functions
// ===============

String.to_list(str: String): List(Char)
  case str:
  | List.nil<>;
  | List.cons<>(str.head)(String.to_list(str.tail));

String.from_list(xs: List(Char)) : String
  case xs:
  | String.nil;
  | String.cons(xs.head,String.from_list(xs.tail));

String.eql(a: String, b: String): Bool
  case a:
  | case b: | Bool.true; | Bool.false;;
  | case b:
    | Bool.false;
    | Bool.and(U16.eql(a.head,b.head),String.eql(a.tail,b.tail));;

String.to_bits(str: String): Bits
  case str:
  | Bits.nil;
  | Bits.concat(U16.to_bits(str.head))(String.to_bits(str.tail));

//String.to_set(str: String): Set
//  case str:
//  | Set.new;
//  | Set.set
//    | U16.to_bits(str.head);
//    | String.to_set(str.tail);;

// A proposition that a string is not the empty string
String.not_empty(xs: String) : Type
  case xs:
  | Empty;
  | Unit;

// A theorem that String.cons isn't String.nil
String.cons_isnt_nil(x:Char, xs: String)
  : Not(Equal(String,String.cons(x,xs), String.nil))
  def P = String.not_empty
  (e) Equal.rewrite<String, String.cons(x,xs), String.nil,P>(e, Unit.new)

// A theorem that a string made with String.cons is not the empty string
String.cons_isnt_empty(x: Char, xs: String): String.not_empty(String.cons(x,xs))
  def y = String.cons(x,xs)
  case y:
  with e : Equal(String,y,y.self) = Equal.to<String,y>;
  | Empty.absurd(String.cons_isnt_nil(x,xs,e),_);
  | Unit.new;

// Concatenates two strings.
String.concat(as: String, bs: String): String
  case as:
  | bs;
  | String.cons(as.head, String.concat(as.tail,bs));

// Concatenate any number of strings
String.concatVar: (n: Nat) -> Variadic(n, String, String)
  Variadic.foldr<,>(String.concat, String.nil)

// Concatenate any number of chars
String.consVar: (n: Nat) -> Variadic(n, Char, String)
  Variadic.foldr<,>(String.cons, String.nil)

// Get the head of a nonempty string
String.head(xs: String, not_empty: String.not_empty(xs)) : Char
  case xs:
  with ne : String.not_empty(xs.self) = not_empty;
  | Empty.absurd(ne, Char);
  | xs.head;

// Get the tail of a nonempty string
String.tail(xs: String, not_empty: String.not_empty(xs)) : String
  case xs:
  with ne : String.not_empty(xs.self) = not_empty;
  | Empty.absurd(ne, String);
  | xs.tail;

// Get the all characters of a nonempty string except the last one
String.init(xs: String, not_empty: String.not_empty(xs)) : String
  case xs:
  with ne : String.not_empty(xs.self) = not_empty;
  | Empty.absurd(ne, String);
  | case xs.tail:
    with e : Equal(_, xs.tail.self,xs.tail) = Equal.to<String,xs.tail>;
    | String.nil;
    | def cne = String.cons_isnt_empty(xs.tail.head,xs.tail.tail)
      def xne = Equal.rewrite<_,_,_,(x) String.not_empty(x)>(e,cne)
      String.cons(xs.head,String.init(xs.tail,xne));;

// Get the last character of a nonempty string
String.last(xs: String, not_empty: String.not_empty(xs)) : Char
  case xs:
  with ne : String.not_empty(xs.self) = not_empty;
  | Empty.absurd(ne, Char);
  | case xs.tail:
    with e : Equal(_, xs.tail.self,xs.tail) = Equal.to<String,xs.tail>;
    | xs.head;
    | def cne = String.cons_isnt_empty(xs.tail.head,xs.tail.tail)
      def xne = Equal.rewrite<_,_,_,(x) String.not_empty(x)>(e,cne)
      String.last(xs.tail,xne);;

String.null(xs: String) : Bool
  case xs:
  | Bool.true;
  | Bool.false;

// Computes the length of the string.
String.length(xs: String): Nat
  String.length.go(xs,0)

String.length.go(xs: String, n: Nat): Nat
  case xs:
  | n;
  | String.length.go(xs.tail,Nat.succ(n));

// Appends character to the end of the string.
String.append(as: String, a: Char): String
  case as:
  | String.pure(a);
  | String.cons(as.head,String.append(as.tail, a));

// String transformations
// ====================

// Applies a function to all characters of the string.
String.map(f: Char -> Char, as: String): String
  case as:
  | String.nil;
  | String.cons(f(as.head),String.map(f,as.tail));

// Map over a string with the index
String.imap(f: Nat -> Char -> Char, xs: String): String
  case xs:
  | String.nil;
  | String.cons(f(0,xs.head),String.imap((n) f(Nat.succ(n)),xs.tail));

// Reverse the order of the characters of the string
String.reverse(xs: String) : String
  String.reverse.go(xs,String.nil)

String.reverse.go(xs: String, res: String): String
  case xs:
  | res;
  | String.reverse.go(xs.tail,String.cons(xs.head,res));

// insert separators between characters, i.e. `[A,B,C] ~> [A,sep,B,sep,C]`
String.intersperse(sep: Char, xs: String): String
  case xs:
  | String.nil;
  | case xs.tail:
    | String.pure(xs.head);
    | String.cons(xs.head,String.cons(sep,String.intersperse(sep,xs.tail)));;

// insert separators between characters, i.e. `[A,B,C] ~> [A,sep,B,sep,C]`
String.intercalate(sep: String, xs: List(String)): String
  String.flatten(List.intersperse<>(sep,xs))

// Reducing Strings
// ==============

// Folds over a string, right associative
String.foldr<B: Type>(b: B, f: Char -> B -> B, xs: String): B
  String.foldr.go<>(b,f,xs,(x) x)

String.foldr.go<B: Type>(b: B, f: Char -> B -> B, xs: String, g: B -> B): B
  case xs:
  | g(b);
  | String.foldr.go<>(b,f,xs.tail,(x) f(xs.head,x));

// Folds over a string, left associative
String.foldl<B: Type>(b: B, f: B -> Char -> B, xs: String): B
  case xs:
  | b;
  | String.foldl<>(f(b,xs.head),f,xs.tail);

// Special folds
// =============

// Flattens a string of strings into a single string.
String.flatten(xs: List(String)): String
  case xs:
  | String.nil;
  | String.concat(xs.head, String.flatten(xs.tail));

// Do all characters satisfy a condition?
String.all(cond: Char -> Bool, string: String): Bool
  case string:
  | Bool.true;
  | case cond(string.head):
    | String.all(cond)(string.tail);
    | Bool.false;;

/// Does any character satisfy a condition?
String.any (cond: Char -> Bool, string: String): Bool
  case string:
  | Bool.false;
  | case cond(string.head):
    | Bool.true;
    | String.any(cond)(string.tail);;

// Print a string
String.show(xs: String): String
  String.Builder.cons('"',String.to_builder(xs))(String.pure('"'))

// String monad
// ==========

// A string with only one character.
String.pure(x : Char) : String
  String.cons(x)(String.nil)

// The bind function of the string Monad.
String.bind(xs: String, f: Char -> String): String
  case xs:
  | String.nil;
  | String.concat(f(xs.head), String.bind(xs.tail,f));

// Substrings
// ========

// Removes the first characters of a string.
String.drop(n: Nat, xs: String):  String
  case n:
  | xs;
  | case xs:
    | String.nil;
    | String.drop(n.pred,xs.tail);;

// Remove characters while a condition is true
String.drop_while(f: Char -> Bool, xs: String): String
  case xs:
  | String.nil;
  | case f(xs.head):
    | String.drop_while(f,xs.tail);
    | xs;;

String.drop_until(f: Char -> Bool, xs: String): String
  String.drop_while((c) Bool.not(f(c)), xs)

// Removes all characters that do not satisfy a condition.
String.filter(f: Char -> Bool, xs: String): String
  case xs:
  | String.nil;
  | case f(xs.head):
    | String.cons(xs.head,String.filter(f, xs.tail));
    | String.filter(f, xs.tail);;

String.span(f: Char -> Bool, xs: String): Pair(String,String)
  case xs:
  | Pair.new<,>(String.nil,String.nil);
  | case f(xs.head):
    | get y z = String.span(f,xs.tail)
      Pair.new<,>(String.cons(xs.head,y),z);
    | Pair.new<,>(String.nil,xs);;

// Returns the first characters of a string, discards the rest.
String.take(n: Nat, xs: String): String
  case xs:
  | String.nil;
  | case n:
    | String.nil;
    | String.cons(xs.head,String.take(n.pred, xs.tail));;

String.split_at(n : Nat, xs: String) : Pair(String,String)
  case xs:
  | Pair.new<,>(String.nil,String.nil);
  | case n:
    | Pair.new<,>(String.nil,xs);
    | case n.pred:
      | Pair.new<,>(String.pure(xs.head),xs.tail);
      | get y z = String.split_at(n.pred,xs.tail)
        Pair.new<,>(String.cons(xs.head,y),z);;;

// String.Builder
// ============

// A lazy String constructor, useful for efficient concatenation
String.Builder: Type
  String -> String

// construct a new builder (it's just the identity function)
String.Builder.new : String.Builder
  (x) x

// turn a builder into a String
String.run_builder(lb: String.Builder): String
  lb(String.nil)

// concatenate two string builders
String.Builder.concat(a: String.Builder, b: String.Builder): String.Builder
   (x) a(b(x))

// prepend an character
String.Builder.cons(c: Char, lb: String.Builder) : String.Builder
  (x) lb(String.cons(c,x))

// convert a string to a builder
String.to_builder(string: String) : String.Builder
  String.to_builder.go(string, String.Builder.new)

String.to_builder.go(string: String, lb: String.Builder) : String.Builder
  case string:
  | lb;
  | String.to_builder.go(string.tail)(String.Builder.cons(string.head, lb));

//// Returns the character at given position.
//String.at(string: String, index: Nat): Maybe(A)
//  case string:
//  | Maybe.none<>;
//  | case index:
//    | Maybe.some<>(string.head);
//    | String.at<>(string.tail)(index.pred);;
//
//String.chunk(n: Nat, xs: String): Maybe(String)
//  case n:
//  | Maybe.some<>(String.nil<>);
//  | case xs:
//    | Maybe.none<>;
//    | Maybe.bind<,>(String.chunk<>(n.pred,xs.tail))
//      | (x) Maybe.some<>(String.cons<>(xs.head,x));;;
//
//// Indexing Strings
//// ==============
//
////Finds the first occurrence that satisfies a condition
//String.find(cond: A -> Bool, xs: String): Maybe(A)
//  case xs:
//  | Maybe.none<>;
//  | case cond(xs.head):
//    | Maybe.some<>(xs.head);
//    | String.find<>(cond)(xs.tail);;
//
//// Finds the last character that satisfies a condition and its index.
//String.find_last(xs: String, f: A -> Nat -> Bool): Maybe(Pair(A)(Nat))
//  String.find_last.go<A>(xs,f,Nat.zero,Maybe.none<>)
//
//String.find_last.go(
//  xs: String,
//  f: A -> Nat -> Bool,
//  n: Nat,
//  res: Maybe(Pair(A,Nat))
//): Maybe(Pair(A,Nat))
//  case xs:
//  | res;
//  | let res = case f(xs.head,n):
//      | Maybe.some<>(Pair.new<,>(xs.head,n));
//      | res;
//    String.find_last.go<>(xs.tail,f,Nat.succ(n),res);
//
//// Finds the first character that satisfies a condition and its index.
//String.ifind(xs: String, f: A -> Nat -> Bool): Maybe(Pair(A,Nat))
//  String.ifind.go<A>(xs,f,Nat.zero)
//
//String.ifind.go(xs: String, f: A -> Nat -> Bool, i: Nat): Maybe(Pair(A,Nat))
//  case xs:
//  | Maybe.none<>;
//  | case f(xs.head,i):
//    | Maybe.some<>(Pair.new<,>(xs.head)(i));
//    | String.ifind.go<>(xs.tail,f,Nat.succ(i));;
//
//// Zipping strings
//// =============
//
//// Given two strings `xs` and `ys`, applies `f(xs[i],ys[i])` for all `i`.
//String.zip_with<A: Type, B: Type, C: Type>(f: A -> B -> C, as: String, bs: String)
//  : String
//  case as:
//  | String.nil<>;
//  | case bs:
//    | String.nil<>;
//    | String.cons<>(f(as.head,bs.head),String.zip_with<,,>(f,as.tail,bs.tail));;
//
//
//
//
////// A String constructor, useful for efficient concatenation
////String.Builder: Type
////  String -> String
////
////String.Builder.concat(a: String.Builder, b: String.Builder): String.Builder
////   (x) a(b(x))
////
////String.Builder.cons(c: Char, s: String.Builder) : String.Builder
////  (x) s(String.cons(c,x))
////
////String.run_builder(s: String.Builder): String
////  s(String.nil)
////
////String.Builder.new: String.Builder
////  (x) x
////
////String.to_builder(list: String) : String.Builder
////  String.to_builder.go(list, String.Builder.new)
////
////String.to_builder.go(list: String, lb: String.Builder) : String.Builder
////  case list:
////  | lb;
////  | String.to_builder.go(list.tail)(String.Builder.cons(list.head, lb));
////
/////// Appends element to the end of the list.
////String.append(as: String, a: Char): String
////  String.append.go(as,a,String.Builder.new)
////
////String.append.go(as: String, a: Char, sb: String.Builder): String
////  case as:
////  | sb(String.pure(a));
////  | String.append.go(as.tail, a, String.Builder.cons(as.head,sb));
////
////String.chunk(n: Nat, str: String): Maybe(String)
////  String.chunk.go(n,str, Maybe.none<>)
////
////String.chunk.go(n: Nat, str: String, chunk: Maybe(String)): Maybe(String)
////  case n:
////  | chunk;
////  | case str:
////    | Maybe.none<String>;
////    | let chunk2 = Maybe.map<><>(String.cons(str.head),chunk)
////      String.chunk.go(n.pred,str.tail, chunk2);;
////
////String.concat(as: String, bs: String): String
////  String.concat.go(as,bs,String.Builder.new)
////
////String.concat.go(as: String, bs: String, lb: String.Builder): String
////  case as:
////  | lb(bs);
////  | String.concat.go(as.tail,bs, String.Builder.cons(as.head,lb));
////
////String.drop(n: Nat, xs: String):  String
////  case n:
////  | xs;
////  | case xs:
////    | String.nil;
////    | String.drop(n.pred,xs.tail);;
////
////String.drop_while(f: Char -> Bool, str: String): String
////  case str:
////  | String.nil;
////  | case f(str.head):
////    | String.drop_while(f,str.tail);
////    | str;;
////
////String.drop_until(f: Char -> Bool, xs: String): String
////  String.drop_while((c) Bool.not(f(c)), xs)
////
////
//////String.filter : (Char -> Bool) -> String -> String
////  //(cond) (str)
////  //case str:
////  //| String.nil;
////  //| (str.head) (str.tail)
////    //case cond(str.head):
////    //| (t) t;
////    //| (t) String.cons(str.head)(t);
////    //| String.filter(cond)(str.tail);;
////
//////String.flatten: List(String) -> String
////  //(as)
////  //case as:
////  //| String.nil;
////  //| (head) (tail) String.concat(head)(String.flatten(tail));
////
//////String.is_empty: String -> Bool
////  //(str)
////  //case str:
////  //| Bool.true;
////  //| (head) (tail) Bool.false;
////
////String.length(str: String) : Nat
////  case str:
////  | Nat.zero;
////  | Nat.succ(String.length(str.tail));
////
//////String.length.go
////
//////String.quote: String -> String
////  //(str) String.cons(Char.quote)(String.concat(str)(String.single(Char.quote)))
////
////String.reverse(str: String) : String
////  String.reverse.go(str,String.nil)
////
////String.reverse.go(str: String, res: String): String
////  case str:
////  | res;
////  | String.reverse.go(str.tail,String.cons(str.head,res));
////
//////// A list with only one element.
////String.pure : (x : Char) -> String
////  (x) String.cons(x,String.nil)
////
//////String.tail: String -> String
////  //(str)
////  //case str:
////  //| String.nil;
////  //| (str.head) (str.tail) str.tail;
////
//////String.take: Nat -> String -> String
////  //(n) (list)
////  //case list:
////  //| String.nil;
////  //| (head) (tail)
////    //case n:
////    //| String.nil;
////    //| (pred) String.cons(head)(String.take(pred)(tail));;
////
////
////  
////
//////String.to_stringifier : String -> Stringifier
////  //(str)
////  //case str:
////  //| (x) x;
////  //| (str.head) (str.tail)
////    //(x) String.cons(str.head)(String.to_stringifier(str.tail)(x));
////

String.take_n(n: Nat, str: String): Maybe(Pair(String, String))
  case String.take_n.aux(n, String.nil, str) as m:
  | Maybe.none<Pair(String, String)>;
  | get x y = m.value
    Maybe.some<>(Pair.new<,>(String.reverse(x), y));

String.take_n.aux(n: Nat, str: String, res: String): Maybe(Pair(String, String))
  case res:
  | case n:
    | Maybe.some<>(Pair.new<,>(str, String.nil));
    | Maybe.none<Pair(String, String)>;;
  | case n:
    | Maybe.some<>(Pair.new<String, String>(str, res));
    | String.take_n.aux(n.pred, String.cons(res.head, str), res.tail);;

